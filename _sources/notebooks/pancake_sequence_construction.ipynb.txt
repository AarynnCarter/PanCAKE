{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "640d3250",
   "metadata": {},
   "source": [
    "# Observational Sequence Construction\n",
    "\n",
    "After the construction of astrophysical scenes to observe, the next stage in a PanCAKE simulation is to describe a sequence of observations that should be simulated. In the [Basic Tutorial](https://aarynncarter.com/PanCAKE/notebooks/pancake_basic_tutorial.html) we briefly covered this, however, this page inclues much more detail on the construction steps and tunable parameters. \n",
    "\n",
    "Important - If you are running PanCAKE within a python script, you will need to place all imports and function calls within the following statement:"
   ]
  },
  {
   "cell_type": "raw",
   "id": "2815aa79-fa55-4eea-b884-4ab7a0fd4a38",
   "metadata": {},
   "source": [
    "if __name__ == '__main__':"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cb518e1c",
   "metadata": {},
   "source": [
    "## The Basics\n",
    "\n",
    "At first we need to create some scenes to observe, and initialise an empty sequence of observations:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "cae6deaf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Target // Adding Source: HIP 65426\n",
      "WARNING: Couldn't determine magnitude system, assuming Vega magnitudes.\n",
      "WARNING: Spectral type 'a2v' not compatible with Pandeia grid, using spectral type 'a1v' instead.\n",
      "Reference // Adding Source: HIP 68245\n",
      "WARNING: Couldn't determine magnitude system, assuming Vega magnitudes.\n",
      "WARNING: Spectral type 'b2iv' not compatible with Pandeia grid, using spectral type 'b1v' instead.\n"
     ]
    }
   ],
   "source": [
    "import pancake\n",
    "\n",
    "# Define the target scene\n",
    "target = pancake.scene.Scene('Target')\n",
    "target.add_source('HIP 65426', kind='simbad')\n",
    "\n",
    "# Define the reference scene\n",
    "reference = pancake.scene.Scene('Reference')\n",
    "reference.add_source('HIP 68245', kind='simbad')\n",
    "\n",
    "# Initialise Observational Sequence\n",
    "seq = pancake.sequence.Sequence()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "71162787",
   "metadata": {},
   "source": [
    "## Adding Observations\n",
    "\n",
    "With an empty sequence defined, we can start to add observations of our scenes in the chronological order in which we want them to be performed using the `add_observation()` method:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7285812a",
   "metadata": {},
   "outputs": [],
   "source": [
    "seq.add_observation(target, exposures=[('F444W', 'DEEP8', 10, 10)])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "54a5678f",
   "metadata": {},
   "source": [
    "Here all we have done is specify the scene we want to observe (the target) and the readout parameters for an exposure we wish to perform. Note that there is no need to specify the instrument, subarray, or even coronagraphic mask and default estimations will be used. In some cases this may not be preferred, in which case see the Observation Specifics section below for further information. \n",
    "\n",
    "The exposure has been split into four properties: Filter, Readout Pattern, Number of Groups, and Number of Integrations. Be careful which way round you put the groups and integrations (Tip: they are ordered alphabetically)! If you have no idea what a readout pattern, groups, or integrations are take a look at the [JWST Documentation](https://jwst-docs.stsci.edu/understanding-exposure-times). If you know what these are, but don't know what pattern / numbers to choose, see the Optimising Readout Parameters section below. \n",
    "\n",
    "If we want to add more exposures, or exposures for different scenes, we simply need to specify calls  to `add_observation()` until the desired observing sequence is complete. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fe44f7da",
   "metadata": {},
   "source": [
    "### Grouping Exposures\n",
    "\n",
    "It's a little inefficient to list the exposures one by one, so the `add_observation()` method also has the functionality to intake multiple exposures simultaneously:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "9aa261f7",
   "metadata": {},
   "outputs": [],
   "source": [
    "seq.add_observation(target, exposures=[('F444W', 'DEEP8', 10, 10), ('F1065C', 'FASTR1', 100, 10)])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "192b2ad5",
   "metadata": {},
   "source": [
    "Where we have simply added a another tuple which describes a second exposure we'd like to perform. Note that the 'F444W' filter is from NIRCam, and the 'F1065C' filter is from MIRI - there is no inherent need to separate your NIRCam and MIRI exposures. However, for a given `add_observation()` call, the default behaviour of PanCAKE is to add exposures to the observational sequence by the coronagraph they are using. In some cases, this will lead to the observations not being simulated in the order that they are listed, and if this is not what you would like you will need to separate the exposures in to distinct `add_observation()` calls."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "91e92930",
   "metadata": {},
   "source": [
    "## Optimising Readout Parameters\n",
    "\n",
    "With multiple readout patterns varying from instrument to instrument, with further varying limits on the number of allowable groups and integrations, it isn't straightforward to determine what parameters to actually use to optimise the SNR you would get for a given amount of time. The correct way to perform such an assessment would be to perform simulations across the readout parameters of interest to identify what maximises the SNR at a desired location within the simulated FOV. Unfortunately, this is too computationally intensive for PanCAKE in its current form. \n",
    "\n",
    "Nevertheless, there is an optimisation routine available which can be used to estimate close to optimal readout parameters relatively quickly. To use it, simply replace the readout parameters for an `'optimise'` string and the number of seconds you want to observe the object for:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "e1d0d04a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Optimising Readout // Target // Exposure: F444W, 3600 seconds\n",
      "--> Pattern: DEEP8, Number of Groups: 20, Number of Integrations: 9 = 3743s\n",
      "Optimising Readout // Target // Exposure: F1065C, 3600 seconds\n",
      "--> Pattern: FAST, Number of Groups: 1251, Number of Integrations: 12 = 3598s\n"
     ]
    }
   ],
   "source": [
    "seq.add_observation(target, exposures=[('F444W', 'optimise', 3600), ('F1065C', 'optimise', 3600)])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5ee3ac6f",
   "metadata": {},
   "source": [
    "As can be seen, the readout parameters have been automatically determined and assigned for future observations. If you want to re-run your code multiple times, you can now replace the optimisation request for these calculated parameters to save time. \n",
    "\n",
    "It is important to understand that this optimisation scheme is  built upon the assumption that the best overall contrast will be achieved with a combination of readout parameters that results in the largest amount of time between  detector resets (i.e. the longest integration times) whilst simultaneously avoiding detector saturation and/or significant cosmic ray contamination. Such constraints maximise the number of photons detected from the astrophysical scene, whilst also minimising the impact of read noise. In reality, it may be that better contrasts can be obtained at wider separations by allowing the innermost regions of the image to saturate, and shorter integrations may be desirable if there is a need to obtain more integration-level images within a defined timescale. Use of this optimisation procedure should be considered carefully; however, in standard circumstances this assumption is unlikely to result in readout parameter estimations that are significantly different from the true optimal values. For futher information on the optimisation, see Section 3.2 and Figure 1 from the [PanCAKE SPIE Paper](https://www.spiedigitallibrary.org/conference-proceedings-of-spie/11823/118230H/Simulating-JWST-high-contrast-observations-with-PanCAKE/10.1117/12.2594501.full?SSO=1)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4995982b",
   "metadata": {},
   "source": [
    "### Scaling Exposures\n",
    "\n",
    "When observing a reference object, in many cases we want to match the number of photons received during our science object, and not necessarily match the exposure time. If our reference is much brighter than the target, we can reduce the exposure time significantly and make our observations much more efficient. \n",
    "\n",
    "In PanCAKE, this \"scaling\" of the exposure time can be performed automatically, and new readout parameters can be optimised:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "53b041ff",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--> Scaling provided exposure times by relative flux of: \"Target\"\n",
      "---> Pattern: DEEP8, Number of Groups: 7, Number of Integrations: 2 = 276s\n",
      "Optimising Readout // Reference // Exposure: F1065C, 3600 seconds\n",
      "--> Scaling provided exposure times by relative flux of: \"Target\"\n",
      "--> Pattern: FAST, Number of Groups: 1116, Number of Integrations: 2 = 535s\n"
     ]
    }
   ],
   "source": [
    "seq.add_observation(reference, exposures=[('F444W', 'DEEP8', 10, 10)], scale_exposures=target)\n",
    "seq.add_observation(reference, exposures=[('F1065C', 'optimise', 3600)], scale_exposures=target)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "576172a4",
   "metadata": {},
   "source": [
    "Here we have demonstrated that the scaling can be performed on a precise set of readout parameters, or one that needs to be optimised. Note that the user input no longer defines the exposure to be performed, but rather a baseline exposure to scale from. To scale the exposure, we have provided the target scene object, in this case the routine will identify the brightest object in both the `reference` and `target` scenes and scale relative to their flux ratio in the provided exposure filter.\n",
    "\n",
    "If you'd prefer to scale things based on a fraction of the defined exposure time, a float or integer can also be used instead:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "6c8694af",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--> Scaling provided exposure times by 0.33\n",
      "---> Pattern: DEEP8, Number of Groups: 7, Number of Integrations: 5 = 690s\n",
      "Optimising Readout // Reference // Exposure: F1065C, 3600 seconds\n",
      "--> Scaling provided exposure times by 0.33\n",
      "--> Pattern: FAST, Number of Groups: 1214, Number of Integrations: 4 = 1164s\n"
     ]
    }
   ],
   "source": [
    "seq.add_observation(reference, exposures=[('F444W', 'DEEP8', 10, 10)], scale_exposures=0.33)\n",
    "seq.add_observation(reference, exposures=[('F1065C', 'optimise', 3600)], scale_exposures=0.33)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a9de863f",
   "metadata": {},
   "source": [
    "### Fine-tuning Optimisation\n",
    "\n",
    "Whilst the optimisation routine is relatively inflexible, there exists some level of fine-tunability through the maximum allowable saturation fraction, and the optimisation margin. \n",
    "\n",
    "By default the optimisation routine will only select readout parameters that correspond to a fraction of full well saturation (for any pixel in the image) of 0.95. If you want to be less strict, or potentially even allow some level of saturation, this value can be adjusted:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "a13412d1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Optimising Readout // Reference // Exposure: F444W, 3600 seconds\n",
      "--> Pattern: DEEP8, Number of Groups: 4, Number of Integrations: 50 = 3689s\n",
      "Optimising Readout // Reference // Exposure: F444W, 3600 seconds\n",
      "--> Pattern: DEEP8, Number of Groups: 10, Number of Integrations: 18 = 3637s\n"
     ]
    }
   ],
   "source": [
    "seq.add_observation(reference, exposures=[('F444W', 'optimise', 3600)], max_sat=0.5)\n",
    "seq.add_observation(reference, exposures=[('F444W', 'optimise', 3600)], max_sat=1.5)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2e4b465a",
   "metadata": {},
   "source": [
    "You may have noticed in the above examples that even though an exposure time of 3600 seconds has been specified, the adopted readout parameters correspond to slightly different exposure durations. Selecting readout parameters that are optimal *and* provide a precise exposure time is very difficult owing to the JWST readout structure. Instead PanCAKE looks for potential exposures within a margin of the provided exposure time. By default this margin is 5% of the provided exposure, but can also be defined manually:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "d0574d51",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Optimising Readout // Reference // Exposure: F444W, 3600 seconds\n",
      "--> Pattern: DEEP8, Number of Groups: 6, Number of Integrations: 31 = 3613s\n",
      "Optimising Readout // Reference // Exposure: F444W, 3600 seconds\n",
      "--> Pattern: DEEP8, Number of Groups: 8, Number of Integrations: 23 = 3664s\n"
     ]
    }
   ],
   "source": [
    "seq.add_observation(reference, exposures=[('F444W', 'optimise', 3600)], optimise_margin=0.01)\n",
    "seq.add_observation(reference, exposures=[('F444W', 'optimise', 3600)], optimise_margin=0.2)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6d3b657e",
   "metadata": {},
   "source": [
    "and we can see that the wider margin of 20% allows for more optimal readout parameters using an exposure only 50 seconds longer than that found with a restrictive margin of 1%. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f9511040",
   "metadata": {},
   "source": [
    "## Observation Specifics\n",
    "\n",
    "In many cases, it will be necessary to provide further specific information to PanCAKE to further define or expand a desired observation."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "783bdbff",
   "metadata": {},
   "source": [
    "### Coronagraphic Mask\n",
    "\n",
    "PanCAKE has differing behaviour with respect to selecting coronagraphic masks depending on whether the NIRCam or MIRI instrument is being used. For MIRI, the coronagraphic mask is intrinsically tied to the observational filter, and there is no need (or capability) to manually define this. However, for NIRCam there are five independent coronagraphic masks, and most filters are compatible with more than one mask ([NIRCam Filters For Coronagraphy](https://jwst-docs.stsci.edu/jwst-near-infrared-camera/nircam-instrumentation/nircam-filters-for-coronagraphy)). The default allocations depending on the input filter are as follows:\n",
    "\n",
    "**MASK210R:** <2.4 micron filters  \\\n",
    "**MASKLWB:** F277W  \\\n",
    "**MASK335R:** Remaining filters >2.4 micron\n",
    "\n",
    "However, the NIRCam mask can also be explictly defined using the `nircam_mask` parameter if necesssary:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "b01b964e",
   "metadata": {},
   "outputs": [],
   "source": [
    "seq.add_observation(target, exposures=[('F444W', 'DEEP8', 10, 10)], nircam_mask='MASK430R')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "44d0939e",
   "metadata": {},
   "source": [
    "### Telescope Rolls\n",
    "\n",
    "To facilitate ADI PSF subtraction routines, it is necessary to roll the telescope and perform an additional observation of our target scene. By default PanCAKE will perform a single roll; however, additional rolls can be defined using the `rolls` parameter:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "c69ef824",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "WARNING: Roll differences of more than 15 degrees are extremely difficult/impossible to schedule.\n"
     ]
    }
   ],
   "source": [
    "seq.add_observation(target, exposures=[('F444W', 'DEEP8', 10, 10)], rolls='max')\n",
    "seq.add_observation(target, exposures=[('F444W', 'DEEP8', 10, 10)], rolls=[0,5,10,20])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7da16425",
   "metadata": {},
   "source": [
    "Here we have demonstrated the two different input options. A list of precise roll values in degrees can be provided, or alternatively a `max` string can be provided to request two rolls at 0 and 14 degrees. Note that the maximum roll possible for JWST to avoid significant solar illumination is ~14 degrees, and whilst rolls larger than this can be simulated, they will not be schedulable."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "abfbaf24",
   "metadata": {},
   "source": [
    "### Small Grid-Dithers\n",
    "\n",
    "Similarly to performing multiple target rolls, it can be beneficial to obtain multiple dithered observations of reference scenes to improve the PSF diversity and facilitate better RDI PSF subtraction routines (more info [here](https://jwst-docs.stsci.edu/methods-and-roadmaps/jwst-high-contrast-imaging/jwst-high-contrast-imaging-proposal-planning/hci-small-grid-dithers)). For coronagraphy, these \"small-grid dithers\" can be applied using the `nircam_sgd` and `miri_sgd` parameters:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "0b62854f",
   "metadata": {},
   "outputs": [],
   "source": [
    "seq.add_observation(reference, exposures=[('F444W', 'DEEP8', 10, 10)], nircam_sgd='5-POINT-BOX')\n",
    "seq.add_observation(reference, exposures=[('F1065C', 'FASTR1', 100, 10)], miri_sgd='5-POINT-SMALL-GRID')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "89ef3a74",
   "metadata": {},
   "source": [
    "where we have provided the name of the dither pattern to be used. As NIRCam and MIRI have different dither offsets / nomenclature, the desired small grid dither pattern must be described individually for each instrument. Information on the NIRCam dithers can be found [here](https://jwst-docs.stsci.edu/jwst-near-infrared-camera/nircam-operations/nircam-dithers-and-mosaics/nircam-subpixel-dithers/nircam-small-grid-dithers) and the MIRI dithers [here](https://jwst-docs.stsci.edu/jwst-mid-infrared-instrument/miri-operations/miri-dithering/miri-coronagraphic-imaging-dithering)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f67a9fb1",
   "metadata": {},
   "source": [
    "## Ancillary Information\n",
    "\n",
    "### Compatible Filters:\n",
    "\n",
    "**NIRCam:** F182M, F187N, F200W, F210M, F212N, F250M, F277W, F300M, F322W2, F335M, F356W, F360M, F410M, F430M, F444W, F460M, F480M \n",
    "\n",
    "**MIRI:** F1065C, F1140C, F1550C\n",
    "\n",
    "### Compatible Masks:\n",
    "\n",
    "**NIRCam:** MASKSWB, MASKLWB, MASK210R, MASK335R, MASK430R\n",
    "\n",
    "**MIRI:** Tied to the chosen filter. \n",
    "\n",
    "### Compatible Dither Patterns:\n",
    "\n",
    "**NIRCam:** 5-POINT-BOX, 5-POINT-DIAMOND, 9-POINT-CIRCLE, 3-POINT-BAR, 5-POINT-BAR\n",
    "\n",
    "**MIRI:** 5-POINT-SMALL-GRID, 9-POINT-SMALL-GRID"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:pcake]",
   "language": "python",
   "name": "conda-env-pcake-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
