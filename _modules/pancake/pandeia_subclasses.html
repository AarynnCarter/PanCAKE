

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pancake.pandeia_subclasses &mdash; PanCAKE 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> PanCAKE
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Welcome to PanCAKEâ€™s documentation!</a></li>
</ul>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/pancake_basic_tutorial.html">Basic Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scene.html">Astrophysical Scene Constuction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sequence.html">Observational Sequence Constuction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../simulation.html">Simulation Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../postprocessing.html">Postprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PanCAKE</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pancake.pandeia_subclasses</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pancake.pandeia_subclasses</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="c1"># Just build an actual subclass of the necessary JWST classes</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">units</span>
<span class="kn">import</span> <span class="nn">astropy.io.fits</span> <span class="k">as</span> <span class="nn">fits</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span> <span class="k">as</span> <span class="nn">integrate</span>
<span class="kn">import</span> <span class="nn">webbpsf</span>
<span class="kn">from</span> <span class="nn">poppy</span> <span class="kn">import</span> <span class="n">poppy_core</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
    <span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">functools32</span> <span class="kn">import</span> <span class="n">lru_cache</span>
    <span class="kn">from</span> <span class="nn">cStringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">pandeia.engine</span>
<span class="kn">from</span> <span class="nn">pandeia.engine</span> <span class="kn">import</span> <span class="n">observation</span>
<span class="kn">from</span> <span class="nn">pandeia.engine</span> <span class="kn">import</span> <span class="n">astro_spectrum</span> <span class="k">as</span> <span class="n">astro</span>
<span class="kn">from</span> <span class="nn">pandeia.engine</span> <span class="kn">import</span> <span class="n">background</span> <span class="k">as</span> <span class="n">bg</span>
<span class="kn">from</span> <span class="nn">pandeia.engine</span> <span class="kn">import</span> <span class="n">coords</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.config</span> <span class="kn">import</span> <span class="n">DefaultConfig</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.report</span> <span class="kn">import</span> <span class="n">Report</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.scene</span> <span class="kn">import</span> <span class="n">Scene</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.calc_utils</span> <span class="kn">import</span> <span class="n">build_empty_scene</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.custom_exceptions</span> <span class="kn">import</span> <span class="n">EngineInputError</span><span class="p">,</span> <span class="n">EngineOutputError</span><span class="p">,</span> <span class="n">RangeError</span><span class="p">,</span> <span class="n">DataError</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.instrument_factory</span> <span class="kn">import</span> <span class="n">InstrumentFactory</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.strategy</span> <span class="kn">import</span> <span class="n">StrategyFactory</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.pandeia_warnings</span> <span class="kn">import</span> <span class="n">etc3d_warning_messages</span> <span class="k">as</span> <span class="n">warning_messages</span>
<span class="kn">from</span> <span class="nn">pandeia.engine</span> <span class="kn">import</span> <span class="n">debug_utils</span>

<span class="kn">from</span> <span class="nn">pandeia.engine.psf_library</span> <span class="kn">import</span> <span class="n">PSFLibrary</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.strategy</span> <span class="kn">import</span> <span class="n">Coronagraphy</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.constants</span> <span class="kn">import</span> <span class="n">SPECTRAL_MAX_SAMPLES</span>
<span class="n">default_SPECTRAL_MAX_SAMPLES</span> <span class="o">=</span> <span class="n">SPECTRAL_MAX_SAMPLES</span>
<span class="kn">from</span> <span class="nn">pandeia.engine.etc3D</span> <span class="kn">import</span> <span class="n">CalculationConfig</span><span class="p">,</span> <span class="n">DetectorSignal</span>
<span class="n">PandeiaDetectorSignal</span> <span class="o">=</span> <span class="n">DetectorSignal</span>

<span class="kn">from</span> <span class="nn">.config</span> <span class="kn">import</span> <span class="n">EngineConfiguration</span>

<span class="n">cache_maxsize</span> <span class="o">=</span> <span class="mi">256</span>     <span class="c1"># Number of monochromatic PSFs stored in an LRU cache</span>
                        <span class="c1"># Should speed up calculations that involve modifying things</span>
                        <span class="c1"># like exposure time and don&#39;t actually require calculating new PSFs.</span>


<div class="viewcode-block" id="CoronagraphyPSFLibrary"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyPSFLibrary">[docs]</a><span class="k">class</span> <span class="nc">CoronagraphyPSFLibrary</span><span class="p">(</span><span class="n">PSFLibrary</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Subclass of the Pandeia PSFLibrary class, intended to allow PSFs to be generated on-the-fly</span>
<span class="sd">    via webbpsf rather than using cached PSFs</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aperture</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.engine</span> <span class="kn">import</span> <span class="n">options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="o">=</span> <span class="n">options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="s2">&quot;CUSTOM PSF LIBRARY ACTIVATE!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;pandeia_refdata&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
                <span class="n">tel</span> <span class="o">=</span> <span class="s1">&#39;jwst&#39;</span>
                <span class="n">ins</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">current_config</span><span class="p">[</span><span class="s1">&#39;configuration&#39;</span><span class="p">][</span><span class="s1">&#39;instrument&#39;</span><span class="p">][</span><span class="s1">&#39;instrument&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;pandeia_refdata&#39;</span><span class="p">],</span> <span class="n">tel</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="s1">&#39;psfs&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CoronagraphyPSFLibrary</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">aperture</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latest_on_the_fly_PSF</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_path</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">cache_path</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>

<div class="viewcode-block" id="CoronagraphyPSFLibrary.associate_offset_to_source"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyPSFLibrary.associate_offset_to_source">[docs]</a>    <span class="k">def</span> <span class="nf">associate_offset_to_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Added azimuth information for use with webbpsf. Pandeia currently does not calculate </span>
<span class="sd">        the PA and assumes azimuthal symmetry resulting in incorrect calculations when using </span>
<span class="sd">        the bar coronagraph. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">psf_offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offsets</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">)</span>
        <span class="n">psf_associations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="n">source_offset_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="s1">&#39;x_offset&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">source</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="s1">&#39;y_offset&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span>
            <span class="n">source_offset_azimuth</span> <span class="o">=</span> <span class="mi">360</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="s1">&#39;x_offset&#39;</span><span class="p">],</span><span class="n">source</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="s1">&#39;y_offset&#39;</span><span class="p">]))</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">psf_associations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source_offset_radius</span><span class="p">,</span><span class="n">source_offset_azimuth</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">psf_associations</span></div>
    
<div class="viewcode-block" id="CoronagraphyPSFLibrary.get_pupil_throughput"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyPSFLibrary.get_pupil_throughput">[docs]</a>    <span class="k">def</span> <span class="nf">get_pupil_throughput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intended for pandeia 1.2 compatibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">CoronagraphyPSFLibrary</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="s2">&quot;get_pupil_throughput&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CoronagraphyPSFLibrary</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_pupil_throughput</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">)</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">_get_instrument</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">_pupil_throughput</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="CoronagraphyPSFLibrary.get_cached_psf"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyPSFLibrary.get_cached_psf">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="n">cache_maxsize</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_cached_psf</span><span class="p">(</span> <span class="n">wave</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">,</span> <span class="n">oversample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source_offset</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">otf_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_aperture</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.engine</span> <span class="kn">import</span> <span class="n">options</span>
        <span class="c1">#Make the instrument and determine the mode</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">_get_instrument</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">,</span> <span class="n">source_offset</span><span class="p">)</span>
        <span class="n">pix_scl</span> <span class="o">=</span> <span class="n">ins</span><span class="o">.</span><span class="n">pixelscale</span>
        <span class="n">fov_pixels</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">fov_pixels</span><span class="p">[</span><span class="n">aperture_name</span><span class="p">]</span>
        <span class="n">trim_fov_pixels</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">trim_fov_pixels</span><span class="p">[</span><span class="n">aperture_name</span><span class="p">]</span>
        
        <span class="n">psf_result</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">calc_psf</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">source_offset</span><span class="p">,</span> <span class="n">oversample</span><span class="p">,</span> <span class="n">pix_scl</span><span class="p">,</span> 
                                                     <span class="n">fov_pixels</span><span class="p">,</span> <span class="n">trim_fov_pixels</span><span class="o">=</span><span class="n">trim_fov_pixels</span><span class="p">)</span>

        <span class="n">pupil_throughput</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">_pupil_throughput</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
        <span class="n">pix_scl</span> <span class="o">=</span> <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;PIXELSCL&#39;</span><span class="p">]</span>
        <span class="n">upsamp</span> <span class="o">=</span> <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OVERSAMP&#39;</span><span class="p">]</span>
        <span class="n">diff_limit</span> <span class="o">=</span> <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;DIFFLMT&#39;</span><span class="p">]</span>
        <span class="n">psf</span> <span class="o">=</span> <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">psf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">psf</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="n">psf</span><span class="p">,</span>
            <span class="s1">&#39;wave&#39;</span><span class="p">:</span> <span class="n">wave</span><span class="p">,</span>
            <span class="s1">&#39;pix_sclx&#39;</span><span class="p">:</span> <span class="n">pix_scl</span><span class="p">,</span>
            <span class="s1">&#39;pix_scly&#39;</span><span class="p">:</span> <span class="n">pix_scl</span><span class="p">,</span>
            <span class="s1">&#39;diff_limit&#39;</span><span class="p">:</span> <span class="n">diff_limit</span><span class="p">,</span>
            <span class="s1">&#39;upsamp&#39;</span><span class="p">:</span> <span class="n">upsamp</span><span class="p">,</span>
            <span class="s1">&#39;instrument&#39;</span><span class="p">:</span> <span class="n">instrument</span><span class="p">,</span>
            <span class="s1">&#39;aperture_name&#39;</span><span class="p">:</span> <span class="n">aperture_name</span><span class="p">,</span>
            <span class="s1">&#39;source_offset&#39;</span><span class="p">:</span> <span class="n">source_offset</span><span class="p">,</span>
            <span class="s1">&#39;pupil_throughput&#39;</span><span class="p">:</span> <span class="n">pupil_throughput</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">psf</span></div>

<div class="viewcode-block" id="CoronagraphyPSFLibrary.get_psf"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyPSFLibrary.get_psf">[docs]</a>    <span class="k">def</span> <span class="nf">get_psf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">,</span> <span class="n">oversample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source_offset</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">otf_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_aperture</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">cache</span>
        <span class="k">if</span> <span class="n">oversample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oversample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">on_the_fly_oversample</span>

        <span class="k">if</span> <span class="n">source_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">50.</span><span class="p">:</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">_get_instrument</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">,</span> <span class="n">source_offset</span><span class="p">)</span>
            <span class="n">diff_limit</span> <span class="o">=</span> <span class="p">((((</span><span class="n">wave</span><span class="o">*</span><span class="n">units</span><span class="o">.</span><span class="n">micron</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">meter</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">/</span><span class="mf">6.5</span><span class="p">)</span><span class="o">*</span><span class="n">units</span><span class="o">.</span><span class="n">radian</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">arcsec</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
            <span class="n">psf</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
                <span class="s1">&#39;wave&#39;</span><span class="p">:</span> <span class="n">wave</span><span class="p">,</span>
                <span class="s1">&#39;pix_sclx&#39;</span><span class="p">:</span> <span class="n">ins</span><span class="o">.</span><span class="n">pixelscale</span><span class="o">/</span><span class="n">oversample</span><span class="p">,</span>
                <span class="s1">&#39;pix_scly&#39;</span><span class="p">:</span> <span class="n">ins</span><span class="o">.</span><span class="n">pixelscale</span><span class="o">/</span><span class="n">oversample</span><span class="p">,</span>
                <span class="s1">&#39;diff_limit&#39;</span><span class="p">:</span> <span class="n">diff_limit</span><span class="p">,</span>
                <span class="s1">&#39;upsamp&#39;</span><span class="p">:</span> <span class="n">oversample</span><span class="p">,</span>
                <span class="s1">&#39;instrument&#39;</span><span class="p">:</span> <span class="n">instrument</span><span class="p">,</span>
                <span class="s1">&#39;aperture_name&#39;</span><span class="p">:</span> <span class="n">aperture_name</span><span class="p">,</span>
                <span class="s1">&#39;source_offset&#39;</span><span class="p">:</span> <span class="n">source_offset</span><span class="p">,</span>
                <span class="s1">&#39;pupil_throughput&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_throughput</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">psf</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;Getting </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">... with caching </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">cache</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">cache</span> <span class="o">==</span> <span class="s1">&#39;disk&#39;</span><span class="p">:</span>
            <span class="n">psf_name</span> <span class="o">=</span> <span class="s1">&#39;cached_</span><span class="si">{:.5f}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{:.5f}</span><span class="s1">_</span><span class="si">{:.5f}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">,</span> <span class="n">source_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">oversample</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_have_psf</span><span class="p">(</span><span class="n">psf_name</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot; Found in cache&quot;</span><span class="p">)</span>
                <span class="n">psf_flux</span><span class="p">,</span> <span class="n">pix_scl</span><span class="p">,</span> <span class="n">diff_limit</span><span class="p">,</span> <span class="n">pupil_throughput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_psf</span><span class="p">(</span><span class="n">psf_name</span><span class="p">)</span>
                <span class="n">psf</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="n">psf_flux</span><span class="p">,</span>
                    <span class="s1">&#39;wave&#39;</span><span class="p">:</span> <span class="n">wave</span><span class="p">,</span>
                    <span class="s1">&#39;pix_sclx&#39;</span><span class="p">:</span> <span class="n">pix_scl</span><span class="p">,</span>
                    <span class="s1">&#39;pix_scly&#39;</span><span class="p">:</span> <span class="n">pix_scl</span><span class="p">,</span>
                    <span class="s1">&#39;diff_limit&#39;</span><span class="p">:</span> <span class="n">diff_limit</span><span class="p">,</span>
                    <span class="s1">&#39;upsamp&#39;</span><span class="p">:</span> <span class="n">oversample</span><span class="p">,</span>
                    <span class="s1">&#39;instrument&#39;</span><span class="p">:</span> <span class="n">instrument</span><span class="p">,</span>
                    <span class="s1">&#39;aperture_name&#39;</span><span class="p">:</span> <span class="n">aperture_name</span><span class="p">,</span>
                    <span class="s1">&#39;source_offset&#39;</span><span class="p">:</span> <span class="n">source_offset</span><span class="p">,</span>
                    <span class="s1">&#39;pupil_throughput&#39;</span><span class="p">:</span> <span class="n">pupil_throughput</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">psf</span>
        <span class="k">elif</span> <span class="n">cache</span> <span class="o">==</span> <span class="s1">&#39;ram&#39;</span><span class="p">:</span>
            <span class="c1"># At this point, splice in the cache wrapper code, since we&#39;re testing moving the lru_cache out of the class to see what happens</span>
            <span class="c1"># Include the on-the-fly override options in the hash key for the lru_cache</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">on_the_fly_webbpsf_opd</span><span class="p">,</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">):</span>
                <span class="n">opd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">on_the_fly_webbpsf_opd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">opd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">on_the_fly_webbpsf_opd</span>

            <span class="n">otf_options</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">on_the_fly_webbpsf_options</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="n">opd</span><span class="p">,])</span>

            <span class="c1"># this may be needed in get_psf; extract it so we can avoid</span>
            <span class="c1"># passing in &#39;self&#39;, which isn&#39;t hashable for the cache lookup</span>
            <span class="n">full_aperture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psfs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;aperture_name&#39;</span><span class="p">]</span>

            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cached_psf</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">,</span> <span class="n">oversample</span><span class="p">,</span> <span class="n">source_offset</span><span class="p">,</span> <span class="n">otf_options</span><span class="o">=</span><span class="n">otf_options</span><span class="p">,</span> <span class="n">full_aperture</span><span class="o">=</span><span class="n">full_aperture</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot; Cache Stats: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cached_psf</span><span class="o">.</span><span class="n">cache_info</span><span class="p">()))</span>
            <span class="k">return</span> <span class="n">tmp</span>

        <span class="c1"># Either disk cache miss or no caching</span>
        <span class="c1">#Make the instrument and determine the mode</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">_get_instrument</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">,</span> <span class="n">source_offset</span><span class="p">)</span>
        <span class="n">pix_scl</span> <span class="o">=</span> <span class="n">ins</span><span class="o">.</span><span class="n">pixelscale</span>
        <span class="n">fov_pixels</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">fov_pixels</span><span class="p">[</span><span class="n">aperture_name</span><span class="p">]</span>
        <span class="n">trim_fov_pixels</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">trim_fov_pixels</span><span class="p">[</span><span class="n">aperture_name</span><span class="p">]</span>
    
        <span class="n">psf_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_psf</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">source_offset</span><span class="p">,</span> <span class="n">oversample</span><span class="p">,</span> <span class="n">pix_scl</span><span class="p">,</span> <span class="n">fov_pixels</span><span class="p">,</span> <span class="n">trim_fov_pixels</span><span class="o">=</span><span class="n">trim_fov_pixels</span><span class="p">)</span>

        <span class="n">pupil_throughput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_throughput</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
        <span class="n">pix_scl_x</span> <span class="o">=</span> <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;PIXELSCL&#39;</span><span class="p">]</span>
        <span class="n">pix_scl_y</span> <span class="o">=</span> <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;PIXELSCL&#39;</span><span class="p">]</span>
        <span class="n">upsamp</span> <span class="o">=</span> <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OVERSAMP&#39;</span><span class="p">]</span>
        <span class="n">diff_limit</span> <span class="o">=</span> <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;DIFFLMT&#39;</span><span class="p">]</span>
        <span class="n">psf</span> <span class="o">=</span> <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">psf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">psf</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="n">psf</span><span class="p">,</span>
            <span class="s1">&#39;wave&#39;</span><span class="p">:</span> <span class="n">wave</span><span class="p">,</span>
            <span class="s1">&#39;pix_sclx&#39;</span><span class="p">:</span> <span class="n">pix_scl_x</span><span class="p">,</span>
            <span class="s1">&#39;pix_scly&#39;</span><span class="p">:</span> <span class="n">pix_scl_y</span><span class="p">,</span>
            <span class="s1">&#39;diff_limit&#39;</span><span class="p">:</span> <span class="n">diff_limit</span><span class="p">,</span>
            <span class="s1">&#39;upsamp&#39;</span><span class="p">:</span> <span class="n">upsamp</span><span class="p">,</span>
            <span class="s1">&#39;instrument&#39;</span><span class="p">:</span> <span class="n">instrument</span><span class="p">,</span>
            <span class="s1">&#39;aperture_name&#39;</span><span class="p">:</span> <span class="n">aperture_name</span><span class="p">,</span>
            <span class="s1">&#39;source_offset&#39;</span><span class="p">:</span> <span class="n">source_offset</span><span class="p">,</span>
            <span class="s1">&#39;pupil_throughput&#39;</span><span class="p">:</span> <span class="n">pupil_throughput</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">cache</span> <span class="o">==</span> <span class="s1">&#39;disk&#39;</span><span class="p">:</span>
            <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;PUPTHR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pupil_throughput</span>
            <span class="n">psf_result</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache_path</span><span class="p">,</span> <span class="n">psf_name</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot; Created and saved to cache.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">psf</span></div>

<div class="viewcode-block" id="CoronagraphyPSFLibrary.get_pix_scale"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyPSFLibrary.get_pix_scale">[docs]</a>    <span class="k">def</span> <span class="nf">get_pix_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get PSF pixel scale for given instrument/aperture.</span>
<span class="sd">        </span>
<span class="sd">        OVERRIDE Pandeia so as to make sure that the pixel scale comes out correctly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aperture_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_aperture</span><span class="p">(</span><span class="n">aperture_name</span><span class="p">)</span>
        <span class="n">upsample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_upsamp</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">)</span>
        <span class="n">pix_scl</span> <span class="o">=</span> <span class="n">aperture_dict</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="n">upsample</span> <span class="c1">#Return twice for x and y pixel scale</span>
        <span class="n">pix_sclx</span><span class="p">,</span> <span class="n">pix_scly</span> <span class="o">=</span> <span class="n">pix_scl</span><span class="p">,</span> <span class="n">pix_scl</span>
        <span class="k">return</span> <span class="n">pix_sclx</span><span class="p">,</span> <span class="n">pix_scly</span></div>

    <span class="k">def</span> <span class="nf">_have_psf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psf_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determine whether a cached PSF exists for a given combination</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache_path</span><span class="p">,</span> <span class="n">psf_name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_psf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psf_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a cached PSF exists for a given combination</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache_path</span><span class="p">,</span> <span class="n">psf_name</span><span class="p">))</span> <span class="k">as</span> <span class="n">inf</span><span class="p">:</span>
            <span class="n">pix_scl</span> <span class="o">=</span> <span class="n">inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;PIXELSCL&#39;</span><span class="p">]</span>
            <span class="n">diff_limit</span> <span class="o">=</span> <span class="n">inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;DIFFLMT&#39;</span><span class="p">]</span>
            <span class="n">pupil_throughput</span> <span class="o">=</span> <span class="n">inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;PUPTHR&#39;</span><span class="p">]</span>
            <span class="n">psf</span> <span class="o">=</span> <span class="n">inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="k">return</span> <span class="n">psf</span><span class="p">,</span> <span class="n">pix_scl</span><span class="p">,</span> <span class="n">diff_limit</span><span class="p">,</span> <span class="n">pupil_throughput</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pupil_throughput</span><span class="p">(</span><span class="n">ins</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines pupil throughput given a webbpsf instrument object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">optsys</span> <span class="o">=</span> <span class="n">ins</span><span class="o">.</span><span class="n">get_optical_system</span><span class="p">()</span>
        <span class="n">ote_pupil</span> <span class="o">=</span> <span class="n">optsys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="n">coron_pupil</span> <span class="o">=</span> <span class="n">optsys</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="n">pupil_throughput</span> <span class="o">=</span> <span class="n">coron_pupil</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">ote_pupil</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pupil_throughput</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_instrument</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">aperture_name</span><span class="p">,</span> <span class="n">source_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.engine</span> <span class="kn">import</span> <span class="n">options</span> <span class="k">as</span> <span class="n">pancake_options</span>
        <span class="n">instrument_config</span> <span class="o">=</span> <span class="n">pancake_options</span><span class="o">.</span><span class="n">current_config</span><span class="p">[</span><span class="s1">&#39;configuration&#39;</span><span class="p">][</span><span class="s1">&#39;instrument&#39;</span><span class="p">]</span>
        <span class="n">scene_config</span> <span class="o">=</span> <span class="n">pancake_options</span><span class="o">.</span><span class="n">current_config</span><span class="p">[</span><span class="s1">&#39;scene&#39;</span><span class="p">]</span>
        <span class="n">ref_config</span> <span class="o">=</span> <span class="n">pancake_options</span><span class="o">.</span><span class="n">current_config</span><span class="p">[</span><span class="s1">&#39;strategy&#39;</span><span class="p">][</span><span class="s1">&#39;psf_subtraction_source&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">source_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">][</span><span class="s1">&#39;x_offset&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">scene_config</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">ref_config</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">][</span><span class="s1">&#39;x_offset&#39;</span><span class="p">]])</span>
            <span class="n">offset_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">][</span><span class="s1">&#39;y_offset&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">scene_config</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">ref_config</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">][</span><span class="s1">&#39;y_offset&#39;</span><span class="p">]])</span>
            <span class="n">source_offset_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">offset_x</span><span class="o">**</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">offset_y</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span>
            <span class="n">source_offset_azimuth</span> <span class="o">=</span> <span class="mi">360</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">offset_x</span><span class="p">,</span> <span class="n">offset_y</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">source_offset</span> <span class="o">=</span> <span class="p">[</span><span class="n">source_offset_radius</span><span class="p">,</span> <span class="n">source_offset_azimuth</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">instrument</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;NIRCAM&#39;</span><span class="p">:</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">webbpsf</span><span class="o">.</span><span class="n">NIRCam</span><span class="p">()</span>
            <span class="n">ins</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">instrument_config</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">nircam_mode</span><span class="p">[</span><span class="n">aperture_name</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;lw_imaging&#39;</span><span class="p">:</span>
                <span class="n">ins</span><span class="o">.</span><span class="n">detector</span> <span class="o">=</span> <span class="s1">&#39;NRCA5&#39;</span>
                <span class="n">ins</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">=</span> <span class="n">ins</span><span class="o">.</span><span class="n">_pixelscale_long</span>
        <span class="k">elif</span> <span class="n">instrument</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;MIRI&#39;</span><span class="p">:</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">webbpsf</span><span class="o">.</span><span class="n">MIRI</span><span class="p">()</span>
            <span class="n">ins</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">instrument_config</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only NIRCam and MIRI are supported instruments!&#39;</span><span class="p">)</span>
        <span class="n">ins</span><span class="o">.</span><span class="n">image_mask</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">image_mask</span><span class="p">[</span><span class="n">aperture_name</span><span class="p">]</span>
        <span class="n">ins</span><span class="o">.</span><span class="n">pupil_mask</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="o">.</span><span class="n">pupil_mask</span><span class="p">[</span><span class="n">aperture_name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">pancake_options</span><span class="o">.</span><span class="n">on_the_fly_webbpsf_options</span><span class="p">:</span>
            <span class="n">ins</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pancake_options</span><span class="o">.</span><span class="n">on_the_fly_webbpsf_options</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pancake_options</span><span class="o">.</span><span class="n">on_the_fly_webbpsf_opd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ins</span><span class="o">.</span><span class="n">pupilopd</span> <span class="o">=</span> <span class="n">pancake_options</span><span class="o">.</span><span class="n">on_the_fly_webbpsf_opd</span>
        <span class="c1">#get offset</span>
        <span class="n">ins</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;source_offset_r&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ins</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;source_offset_theta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ins</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;output_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;oversampled&#39;</span>
        <span class="n">ins</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;parity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;odd&#39;</span>
        <span class="k">return</span> <span class="n">ins</span>
    
<div class="viewcode-block" id="CoronagraphyPSFLibrary.parse_aperture"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyPSFLibrary.parse_aperture">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">parse_aperture</span><span class="p">(</span><span class="n">aperture_name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return [image mask, pupil mask, fov_pixels, trim_fov_pixels, pixelscale]</span>
<span class="sd">        &#39;&#39;&#39;</span>
    
        <span class="n">aperture_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mask210r&#39;</span><span class="p">,</span><span class="s1">&#39;mask335r&#39;</span><span class="p">,</span><span class="s1">&#39;mask430r&#39;</span><span class="p">,</span><span class="s1">&#39;masklwb&#39;</span><span class="p">,</span><span class="s1">&#39;maskswb&#39;</span><span class="p">,</span><span class="s1">&#39;fqpm1065&#39;</span><span class="p">,</span><span class="s1">&#39;fqpm1140&#39;</span><span class="p">,</span><span class="s1">&#39;fqpm1550&#39;</span><span class="p">,</span><span class="s1">&#39;lyot2300&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">aperture_name</span> <span class="ow">in</span> <span class="n">aperture_keys</span><span class="p">,</span> <span class="s1">&#39;Aperture </span><span class="si">{}</span><span class="s1"> not recognized! Must be one of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aperture_name</span><span class="p">,</span> <span class="n">aperture_keys</span><span class="p">)</span>

        <span class="n">nc</span> <span class="o">=</span> <span class="n">webbpsf</span><span class="o">.</span><span class="n">NIRCam</span><span class="p">()</span>
        <span class="n">miri</span> <span class="o">=</span> <span class="n">webbpsf</span><span class="o">.</span><span class="n">MIRI</span><span class="p">()</span>

        <span class="n">aperture_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;mask210r&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;MASK210R&#39;</span><span class="p">,</span><span class="s1">&#39;CIRCLYOT&#39;</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nc</span><span class="o">.</span><span class="n">_pixelscale_short</span><span class="p">,</span> <span class="s1">&#39;sw_imaging&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mask335r&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;MASK335R&#39;</span><span class="p">,</span><span class="s1">&#39;CIRCLYOT&#39;</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nc</span><span class="o">.</span><span class="n">_pixelscale_long</span><span class="p">,</span> <span class="s1">&#39;lw_imaging&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mask430r&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;MASK430R&#39;</span><span class="p">,</span><span class="s1">&#39;CIRCLYOT&#39;</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nc</span><span class="o">.</span><span class="n">_pixelscale_long</span><span class="p">,</span> <span class="s1">&#39;lw_imaging&#39;</span><span class="p">],</span>
            <span class="s1">&#39;masklwb&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;MASKLWB&#39;</span><span class="p">,</span><span class="s1">&#39;WEDGELYOT&#39;</span><span class="p">,</span> <span class="mi">351</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="n">nc</span><span class="o">.</span><span class="n">_pixelscale_long</span><span class="p">,</span> <span class="s1">&#39;lw_imaging&#39;</span><span class="p">],</span>
            <span class="s1">&#39;maskswb&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;MASKSWB&#39;</span><span class="p">,</span><span class="s1">&#39;WEDGELYOT&#39;</span><span class="p">,</span> <span class="mi">351</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="n">nc</span><span class="o">.</span><span class="n">_pixelscale_short</span><span class="p">,</span> <span class="s1">&#39;sw_imaging&#39;</span><span class="p">],</span>
            <span class="s1">&#39;fqpm1065&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;FQPM1065&#39;</span><span class="p">,</span><span class="s1">&#39;MASKFQPM&#39;</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">miri</span><span class="o">.</span><span class="n">pixelscale</span><span class="p">,</span> <span class="s1">&#39;imaging&#39;</span><span class="p">],</span>
            <span class="s1">&#39;fqpm1140&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;FQPM1140&#39;</span><span class="p">,</span><span class="s1">&#39;MASKFQPM&#39;</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">miri</span><span class="o">.</span><span class="n">pixelscale</span><span class="p">,</span> <span class="s1">&#39;imaging&#39;</span><span class="p">],</span>
            <span class="s1">&#39;fqpm1550&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;FQPM1550&#39;</span><span class="p">,</span><span class="s1">&#39;MASKFQPM&#39;</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">miri</span><span class="o">.</span><span class="n">pixelscale</span><span class="p">,</span> <span class="s1">&#39;imaging&#39;</span><span class="p">],</span>
            <span class="s1">&#39;lyot2300&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;LYOT2300&#39;</span><span class="p">,</span><span class="s1">&#39;MASKLYOT&#39;</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">miri</span><span class="o">.</span><span class="n">pixelscale</span><span class="p">,</span> <span class="s1">&#39;imaging&#39;</span><span class="p">]</span>
            <span class="p">}</span>
    
        <span class="k">return</span> <span class="n">aperture_dict</span><span class="p">[</span><span class="n">aperture_name</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoronagraphyPSFLibrary.calc_psf"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyPSFLibrary.calc_psf">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calc_psf</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">oversample</span><span class="p">,</span> <span class="n">pix_scale</span><span class="p">,</span> <span class="n">fov_pixels</span><span class="p">,</span> <span class="n">trim_fov_pixels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Following the treatment in pandeia_data/dev/make_psf.py to handle</span>
<span class="sd">        off-center PSFs for use as a kernel in later convolutions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Split out offset</span>
        <span class="n">offset_r</span><span class="p">,</span> <span class="n">offset_theta</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="c1"># Create an optical system model. This is done because, in order to determine the critical angle, we need this model, and it otherwise</span>
        <span class="c1">#    wouldn&#39;t be generated until the PSF itself is generated. In this case, we want to generate the model early because we want to make</span>
        <span class="c1">#    sure that the observation *isn&#39;t* over the critical angle *before* generating the PSF</span>
        <span class="n">optsys</span> <span class="o">=</span> <span class="n">ins</span><span class="o">.</span><span class="n">get_optical_system</span><span class="p">(</span><span class="n">fft_oversample</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">detector_oversample</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">fov_arcsec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fov_pixels</span><span class="o">=</span><span class="n">fov_pixels</span><span class="p">)</span>
        <span class="c1"># determine the spatial frequency which is Nyquist sampled by the input pupil.</span>
        <span class="c1"># convert this to units of cycles per meter and make it not a Quantity</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">optsys</span><span class="o">.</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">pixel</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">units</span><span class="o">.</span><span class="n">meter</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="n">critical_angle_arcsec</span> <span class="o">=</span> <span class="n">wave</span><span class="o">*</span><span class="mf">1.e-6</span><span class="o">*</span><span class="n">sf</span><span class="o">*</span><span class="n">poppy_core</span><span class="o">.</span><span class="n">_RADIANStoARCSEC</span>
        <span class="n">critical_angle_pixels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">critical_angle_arcsec</span> <span class="o">/</span> <span class="n">pix_scale</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">offset_r</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="c1">#roll back to center</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span> <span class="n">offset_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">offset_theta</span><span class="p">))</span> <span class="o">/</span> <span class="n">pix_scale</span> <span class="p">))</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span> <span class="n">offset_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">offset_theta</span><span class="p">))</span> <span class="o">/</span> <span class="n">pix_scale</span> <span class="p">))</span>
            <span class="n">dmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">)])</span>

            <span class="n">psf_result</span> <span class="o">=</span> <span class="n">ins</span><span class="o">.</span><span class="n">calc_psf</span><span class="p">(</span><span class="n">monochromatic</span><span class="o">=</span><span class="n">wave</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">oversample</span><span class="o">=</span><span class="n">oversample</span><span class="p">,</span> <span class="n">fov_pixels</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">critical_angle_pixels</span><span class="p">,</span> <span class="n">fov_pixels</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dmax</span><span class="p">))</span>
        
            <span class="n">image</span> <span class="o">=</span> <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">oversample</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">-</span><span class="n">dy</span> <span class="o">*</span> <span class="n">oversample</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">dmax</span> <span class="o">*</span> <span class="n">oversample</span><span class="p">:(</span><span class="n">fov_pixels</span> <span class="o">+</span> <span class="n">dmax</span><span class="p">)</span> <span class="o">*</span> <span class="n">oversample</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">*</span> <span class="n">oversample</span><span class="p">:(</span><span class="n">fov_pixels</span> <span class="o">+</span> <span class="n">dmax</span><span class="p">)</span> <span class="o">*</span> <span class="n">oversample</span><span class="p">]</span>
            <span class="c1">#trim if requested</span>
            <span class="k">if</span> <span class="n">trim_fov_pixels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trim_amount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">oversample</span> <span class="o">*</span> <span class="p">(</span><span class="n">fov_pixels</span> <span class="o">-</span> <span class="n">trim_fov_pixels</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">trim_amount</span><span class="p">:</span><span class="o">-</span><span class="n">trim_amount</span><span class="p">,</span> <span class="n">trim_amount</span><span class="p">:</span><span class="o">-</span><span class="n">trim_amount</span><span class="p">]</span>
            <span class="n">psf_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psf_result</span> <span class="o">=</span> <span class="n">ins</span><span class="o">.</span><span class="n">calc_psf</span><span class="p">(</span><span class="n">monochromatic</span><span class="o">=</span><span class="n">wave</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">oversample</span><span class="o">=</span><span class="n">oversample</span><span class="p">,</span> <span class="n">fov_pixels</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">critical_angle_pixels</span><span class="p">,</span> <span class="n">fov_pixels</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">psf_result</span></div>
    
    <span class="k">def</span> <span class="nf">_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A bypass for the inability for Pandeia to do some internal python class serialization if the</span>
<span class="sd">        class contains a logger</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="n">level</span><span class="o">.</span><span class="n">lower</span><span class="p">()):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Logger has no function </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Message is: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>
        <span class="n">logging_fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="n">level</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="n">logging_fn</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    
    <span class="n">nircam_mode</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;mask210r&#39;</span><span class="p">:</span> <span class="s1">&#39;sw_imaging&#39;</span><span class="p">,</span> <span class="s1">&#39;mask335r&#39;</span><span class="p">:</span> <span class="s1">&#39;lw_imaging&#39;</span><span class="p">,</span> <span class="s1">&#39;mask430r&#39;</span><span class="p">:</span> <span class="s1">&#39;lw_imaging&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;masklwb&#39;</span><span class="p">:</span> <span class="s1">&#39;lw_imaging&#39;</span><span class="p">,</span> <span class="s1">&#39;maskswb&#39;</span><span class="p">:</span> <span class="s1">&#39;sw_imaging&#39;</span><span class="p">,</span> <span class="s1">&#39;fqpm1065&#39;</span><span class="p">:</span> <span class="s1">&#39;imaging&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;fqpm1140&#39;</span><span class="p">:</span> <span class="s1">&#39;imaging&#39;</span><span class="p">,</span> <span class="s1">&#39;fqpm1550&#39;</span><span class="p">:</span> <span class="s1">&#39;imaging&#39;</span><span class="p">,</span> <span class="s1">&#39;lyot2300&#39;</span><span class="p">:</span> <span class="s1">&#39;imaging&#39;</span>
                  <span class="p">}</span>

    <span class="n">image_mask</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;mask210r&#39;</span><span class="p">:</span> <span class="s1">&#39;MASK210R&#39;</span><span class="p">,</span> <span class="s1">&#39;mask335r&#39;</span><span class="p">:</span> <span class="s1">&#39;MASK335R&#39;</span><span class="p">,</span> <span class="s1">&#39;mask430r&#39;</span><span class="p">:</span> <span class="s1">&#39;MASK430R&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;masklwb&#39;</span><span class="p">:</span> <span class="s1">&#39;MASKLWB&#39;</span><span class="p">,</span> <span class="s1">&#39;maskswb&#39;</span><span class="p">:</span> <span class="s1">&#39;MASKSWB&#39;</span><span class="p">,</span> <span class="s1">&#39;fqpm1065&#39;</span><span class="p">:</span> <span class="s1">&#39;FQPM1065&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;fqpm1140&#39;</span><span class="p">:</span> <span class="s1">&#39;FQPM1140&#39;</span><span class="p">,</span> <span class="s1">&#39;fqpm1550&#39;</span><span class="p">:</span> <span class="s1">&#39;FQPM1550&#39;</span><span class="p">,</span> <span class="s1">&#39;lyot2300&#39;</span><span class="p">:</span> <span class="s1">&#39;LYOT2300&#39;</span>
                 <span class="p">}</span>
    
    <span class="n">pupil_mask</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;mask210r&#39;</span><span class="p">:</span> <span class="s1">&#39;CIRCLYOT&#39;</span><span class="p">,</span> <span class="s1">&#39;mask335r&#39;</span><span class="p">:</span> <span class="s1">&#39;CIRCLYOT&#39;</span><span class="p">,</span> <span class="s1">&#39;mask430r&#39;</span><span class="p">:</span> <span class="s1">&#39;CIRCLYOT&#39;</span><span class="p">,</span> 
                    <span class="s1">&#39;masklwb&#39;</span><span class="p">:</span> <span class="s1">&#39;WEDGELYOT&#39;</span><span class="p">,</span> <span class="s1">&#39;maskswb&#39;</span><span class="p">:</span> <span class="s1">&#39;WEDGELYOT&#39;</span><span class="p">,</span> <span class="s1">&#39;fqpm1065&#39;</span><span class="p">:</span> <span class="s1">&#39;MASKFQPM&#39;</span><span class="p">,</span> 
                    <span class="s1">&#39;fqpm1140&#39;</span><span class="p">:</span> <span class="s1">&#39;MASKFQPM&#39;</span><span class="p">,</span> <span class="s1">&#39;fqpm1550&#39;</span><span class="p">:</span> <span class="s1">&#39;MASKFQPM&#39;</span><span class="p">,</span> <span class="s1">&#39;lyot2300&#39;</span><span class="p">:</span> <span class="s1">&#39;MASKLYOT&#39;</span>
                 <span class="p">}</span>
    
    <span class="n">fov_pixels</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;mask210r&#39;</span><span class="p">:</span> <span class="mi">101</span><span class="p">,</span> <span class="s1">&#39;mask335r&#39;</span><span class="p">:</span> <span class="mi">101</span><span class="p">,</span> <span class="s1">&#39;mask430r&#39;</span><span class="p">:</span> <span class="mi">101</span><span class="p">,</span> <span class="s1">&#39;masklwb&#39;</span><span class="p">:</span> <span class="mi">351</span><span class="p">,</span> 
                    <span class="s1">&#39;maskswb&#39;</span><span class="p">:</span> <span class="mi">351</span><span class="p">,</span> <span class="s1">&#39;fqpm1065&#39;</span><span class="p">:</span> <span class="mi">81</span><span class="p">,</span> <span class="s1">&#39;fqpm1140&#39;</span><span class="p">:</span> <span class="mi">81</span><span class="p">,</span> <span class="s1">&#39;fqpm1550&#39;</span><span class="p">:</span> <span class="mi">81</span><span class="p">,</span> 
                    <span class="s1">&#39;lyot2300&#39;</span><span class="p">:</span> <span class="mi">81</span>
                 <span class="p">}</span>
    
    <span class="n">trim_fov_pixels</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;mask210r&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;mask335r&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;mask430r&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;masklwb&#39;</span><span class="p">:</span> <span class="mi">101</span><span class="p">,</span> 
                        <span class="s1">&#39;maskswb&#39;</span><span class="p">:</span> <span class="mi">101</span><span class="p">,</span> <span class="s1">&#39;fqpm1065&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;fqpm1140&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;fqpm1550&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="s1">&#39;lyot2300&#39;</span><span class="p">:</span> <span class="kc">None</span>
                      <span class="p">}</span></div>


<div class="viewcode-block" id="CoronagraphyConvolvedSceneCube"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyConvolvedSceneCube">[docs]</a><span class="k">class</span> <span class="nc">CoronagraphyConvolvedSceneCube</span><span class="p">(</span><span class="n">pandeia</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">astro_spectrum</span><span class="o">.</span><span class="n">ConvolvedSceneCube</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This class overrides the ConvolvedSceneCube class, and instead of using SPECTRAL_MAX_SAMPLES it</span>
<span class="sd">    looks for a wavelength size that should be present in the &#39;scene&#39; part of the template</span>
<span class="sd">    </span>
<span class="sd">    background=None, psf_library=None, webapp=False, empty_scene=False</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.engine</span> <span class="kn">import</span> <span class="n">options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coronagraphy_options</span> <span class="o">=</span> <span class="n">options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="o">=</span> <span class="n">options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="s2">&quot;CORONAGRAPHY SCENE CUBE ACTIVATE!&quot;</span><span class="p">)</span>
        <span class="n">pandeia</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">astro_spectrum</span><span class="o">.</span><span class="n">SPECTRAL_MAX_SAMPLES</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_samples</span>
        <span class="k">if</span> <span class="s1">&#39;psf_library&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;psf_library&#39;</span><span class="p">],</span> <span class="n">CoronagraphyPSFLibrary</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;psf_library&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CoronagraphyConvolvedSceneCube</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_max_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is intended to replace a constant with a function. Maybe it works?</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coronagraphy_options</span><span class="o">.</span><span class="n">wave_sampling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default_SPECTRAL_MAX_SAMPLES</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coronagraphy_options</span><span class="o">.</span><span class="n">wave_sampling</span>

    <span class="k">def</span> <span class="nf">_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A bypass for the inability for Pandeia to do some internal python class serialization if the</span>
<span class="sd">        class contains a logger</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">logging_fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
        <span class="n">logging_fn</span><span class="p">(</span><span class="n">message</span><span class="p">)</span></div>


<div class="viewcode-block" id="CoronagraphyDetectorSignal"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal">[docs]</a><span class="k">class</span> <span class="nc">CoronagraphyDetectorSignal</span><span class="p">(</span><span class="n">CoronagraphyConvolvedSceneCube</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Override the DetectorSignal to avoid odd issues with inheritance. Unfortunately this currently</span>
<span class="sd">    means copying the functions entirely (with changes to which class is used)</span>
<span class="sd">    </span>
<span class="sd">    webapp=False, order=None, empty_scene=False</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">calc_config</span><span class="o">=</span><span class="n">CalculationConfig</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Get calculation configuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculation_config</span> <span class="o">=</span> <span class="n">calc_config</span>

        <span class="c1"># Link to the passed observation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observation</span> <span class="o">=</span> <span class="n">observation</span>

        <span class="c1"># Load the instrument we&#39;re using</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span> <span class="o">=</span> <span class="n">observation</span><span class="o">.</span><span class="n">instrument</span>
        <span class="c1"># save order to the DetectorSignal instance, for convenience purposes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;order&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
        <span class="c1"># and configure the instrument for that order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span>
        
        <span class="c1"># Get optional arguments</span>
        <span class="n">webapp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;webapp&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">empty_scene</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;empty_scene&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># Add coronagraphy-specific PSF library for on-the-fly PSF generation</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;psf_library&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">CoronagraphyPSFLibrary</span><span class="p">()</span>

        <span class="c1"># how are we projecting the signal onto the detector plane?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">projection_type</span>

        <span class="c1"># If we&#39;re in a dispersed mode, we need to know which axis the signal is dispersed along</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispersion_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">dispersion_axis</span><span class="p">()</span>

        <span class="c1"># Get the detector parameters (read noise, etc.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_detector_pars</span><span class="p">()</span>

        <span class="c1"># Initialize detector mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">det_mask</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Get the background</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculation_config</span><span class="o">.</span><span class="n">effects</span><span class="p">[</span><span class="s1">&#39;background&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="n">bg</span><span class="o">.</span><span class="n">Background</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observation</span><span class="p">,</span> <span class="n">webapp</span><span class="o">=</span><span class="n">webapp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;background&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span>

        <span class="c1"># Then initialize the flux and wavelength grid</span>
        <span class="n">CoronagraphyConvolvedSceneCube</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">observation</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="o">.</span><span class="n">warnings</span><span class="p">)</span>
        <span class="c1"># We have to propagate the background through the system transmission</span>
        <span class="c1"># to get the background in e-/s/pixel/micron. The background rate is a 1D spectrum.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg_fp_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bg_fp_rate</span><span class="p">()</span>

        <span class="c1"># Initialize slice lists</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate_plus_bg_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saturation_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixgrid_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Loop over all slices and calculate the photon and electron rates through the</span>
        <span class="c1"># observatory for each one. Note that many modes (imaging, etc.) will have just</span>
        <span class="c1"># a single slice.</span>
        <span class="k">for</span> <span class="n">flux_cube</span><span class="p">,</span> <span class="n">flux_plus_bg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_cube_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_plus_bg_list</span><span class="p">):</span>
            <span class="c1"># Rates for the slice without the background</span>
            <span class="n">slice_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_rates</span><span class="p">(</span><span class="n">flux_cube</span><span class="p">,</span> <span class="n">add_extended_background</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Rates for the slice with the background added</span>
            <span class="n">slice_rate_plus_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_rates</span><span class="p">(</span><span class="n">flux_plus_bg</span><span class="p">,</span> <span class="n">add_extended_background</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Saturation map for the slice</span>
            <span class="n">slice_saturation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_saturation_mask</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">slice_rate_plus_bg</span><span class="p">[</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">])</span>
            <span class="n">exposure_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">exposure_spec</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">exposure_spec</span><span class="p">,</span> <span class="s1">&#39;get_groups_before_sat&#39;</span><span class="p">):</span>
                <span class="n">slice_group</span> <span class="o">=</span> <span class="n">exposure_spec</span><span class="o">.</span><span class="n">get_groups_before_sat</span><span class="p">(</span><span class="n">slice_rate_plus_bg</span><span class="p">[</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">],</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span><span class="p">[</span><span class="s1">&#39;fullwell&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slice_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups_before_sat</span><span class="p">(</span><span class="n">slice_rate_plus_bg</span><span class="p">[</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span><span class="p">[</span><span class="s1">&#39;fullwell&#39;</span><span class="p">])</span>

            <span class="c1"># The grid in the slice</span>
            <span class="n">slice_pixgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pix_grid</span><span class="p">(</span><span class="n">slice_rate</span><span class="p">)</span>

            <span class="c1"># Append all slices to the master lists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rate_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_rate</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rate_plus_bg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_rate_plus_bg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saturation_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_saturation</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groups_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pixgrid_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_pixgrid</span><span class="p">)</span>

        <span class="c1"># Get the mapping of wavelength to pixels on the detector plane. This is grabbed from the</span>
        <span class="c1"># first entry in self.rate_list and is currently defined to be the same for all slices.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_wave_pix</span><span class="p">()</span>

        <span class="c1"># This is also grabbed from the first slice as a diagnostic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fp_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fp_rate</span><span class="p">()</span>

        <span class="c1"># Note that the 2D image due to background alone may have spatial structure due to instrumental effects.</span>
        <span class="c1"># Therefore it is calculated here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg_pix_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bg_pix_rate</span><span class="p">()</span>

        <span class="c1"># Check to see if the background is saturating</span>
        <span class="n">bgsat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_saturation_mask</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bg_pix_rate</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bgsat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bgsat</span><span class="p">))):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;background_saturated&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">warning_messages</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Reassemble rates of multiple slices on the detector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_detector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rate_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate_plus_bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_detector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rate_plus_bg_list</span><span class="p">)</span>

        <span class="n">exposure_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">exposure_spec</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">exposure_spec</span><span class="p">,</span> <span class="s1">&#39;get_groups_before_sat&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ngroup_map</span> <span class="o">=</span> <span class="n">exposure_spec</span><span class="o">.</span><span class="n">get_groups_before_sat</span><span class="p">(</span><span class="n">slice_rate_plus_bg</span><span class="p">[</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">],</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span><span class="p">[</span><span class="s1">&#39;fullwell&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ngroup_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups_before_sat</span><span class="p">(</span><span class="n">slice_rate_plus_bg</span><span class="p">[</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span><span class="p">[</span><span class="s1">&#39;fullwell&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">exposure_spec</span><span class="p">,</span> <span class="s1">&#39;get_saturation_fraction&#39;</span><span class="p">):</span>
            <span class="n">saturation_fraction</span> <span class="o">=</span> <span class="n">exposure_spec</span><span class="o">.</span><span class="n">get_saturation_fraction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rate_plus_bg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span><span class="p">[</span><span class="s1">&#39;fullwell&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">saturation_fraction</span> <span class="o">=</span> <span class="n">exposure_spec</span><span class="o">.</span><span class="n">saturation_time</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span><span class="p">[</span><span class="s1">&#39;fullwell&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_plus_bg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fraction_saturation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">saturation_fraction</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">detector_pixels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_detector_pixels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_pix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">brightest_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rate_plus_bg</span><span class="p">)</span>

        <span class="c1"># Get the read noise correlation matrix and store it as an attribute.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span><span class="p">[</span><span class="s1">&#39;rn_correlation&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_noise_correlation_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_readnoise_correlation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
<div class="viewcode-block" id="CoronagraphyDetectorSignal.spectral_detector_transform"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.spectral_detector_transform">[docs]</a>    <span class="k">def</span> <span class="nf">spectral_detector_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create engine API format dict section containing properties of wavelength coordinates</span>
<span class="sd">        at the detector plane.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t: dict (engine API compliant keys)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_refpix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_pix</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_pix</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="c1"># there are currently three projection_type&#39;s which are basically detector plane types:</span>
        <span class="c1">#</span>
        <span class="c1"># &#39;spec&#39; - where the detector plane is purely dispersion vs. spatial</span>
        <span class="c1"># &#39;slitless&#39; - basically a special case of &#39;spec&#39; with where dispersion and spatial are mixed</span>
        <span class="c1"># &#39;image&#39; - where the detector plane is purely spatial vs. spatial (i.e. no disperser element)</span>
        <span class="c1">#</span>
        <span class="c1"># &#39;IFU&#39; mode is of projection_type=&#39;spec&#39; because the mapping from detector X pixels to</span>
        <span class="c1"># wavelength is the same for each slice.  this projection_type will work for &#39;MSA&#39; mode as well</span>
        <span class="c1"># because we will only handle one aperture at a time.  &#39;slitless&#39; spectroscopy will mix</span>
        <span class="c1"># spatial and dispersion information onto the detector X axis.  however, the detector</span>
        <span class="c1"># plane is fundamentally spatial vs. wavelength in that case so it&#39;s handled the same as</span>
        <span class="c1"># projection_type=&#39;spec&#39;. creating a spectrum for a specific target will be handled via the</span>
        <span class="c1"># extraction strategy.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;spec&#39;</span><span class="p">,</span> <span class="s1">&#39;slitless&#39;</span><span class="p">,</span> <span class="s1">&#39;multiorder&#39;</span><span class="p">):</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_pix</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_pix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># we don&#39;t yet have a way of handling non-linear coordinate transforms here. that said,</span>
                <span class="c1"># this is mostly right for most of our cases with nirspec prism being the notable exception.</span>
                <span class="c1"># this is also only used for plotting purposes while the true actual wave_pix mapping is used</span>
                <span class="c1"># internally for all calculations.</span>
                <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_pix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_size&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_refval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="o">==</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_refval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Unsupported projection_type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span>
            <span class="k">raise</span> <span class="n">EngineOutputError</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">message</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.wcs_info"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.wcs_info">[docs]</a>    <span class="k">def</span> <span class="nf">wcs_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get detector coordinate transform as a dict of WCS keyword/value pairs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        header: dict</span>
<span class="sd">            WCS header keys defining coordinate transform in the detector plane</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="c1"># if we&#39;re in imaging mode, the detector sampling is the same as the model</span>
            <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">wcs_info</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;spec&#39;</span><span class="p">,</span> <span class="s1">&#39;slitless&#39;</span><span class="p">,</span> <span class="s1">&#39;multiorder&#39;</span><span class="p">):</span>
            <span class="c1"># if we&#39;re in a dispersed mode, dispersion can be either along the X or Y axis. the image outputs in</span>
            <span class="c1"># the engine Report are rotated so that dispersion will always appear to be along the X axis with</span>
            <span class="c1"># wavelength increasing with increasing X (i. e. dispersion angle of 0).  currently, the only other</span>
            <span class="c1"># supported dispersion angle is 90 which is what we get when dispersion_axis == &#39;y&#39;.</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
            <span class="n">t</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_detector_transform</span><span class="p">())</span>
            <span class="n">header</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;ctype1&#39;</span><span class="p">:</span> <span class="s1">&#39;Wavelength&#39;</span><span class="p">,</span>
                <span class="s1">&#39;crpix1&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;crval1&#39;</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_min&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_step&#39;</span><span class="p">],</span>
                <span class="s1">&#39;cdelt1&#39;</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;wave_det_step&#39;</span><span class="p">],</span>
                <span class="s1">&#39;cunit1&#39;</span><span class="p">:</span> <span class="s1">&#39;um&#39;</span><span class="p">,</span>
                <span class="s1">&#39;cname1&#39;</span><span class="p">:</span> <span class="s1">&#39;Wavelength&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ctype2&#39;</span><span class="p">:</span> <span class="s1">&#39;Y offset&#39;</span><span class="p">,</span>
                <span class="s1">&#39;crpix2&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;crval2&#39;</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;y_min&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;y_step&#39;</span><span class="p">],</span>
                <span class="s1">&#39;cdelt2&#39;</span><span class="p">:</span> <span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;y_step&#39;</span><span class="p">],</span>
                <span class="s1">&#39;cunit2&#39;</span><span class="p">:</span> <span class="s1">&#39;arcsec&#39;</span><span class="p">,</span>
                <span class="s1">&#39;cname2&#39;</span><span class="p">:</span> <span class="s1">&#39;Detector Offset&#39;</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispersion_axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                <span class="n">header</span><span class="p">[</span><span class="s1">&#39;ctype2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;X offset&#39;</span>
                <span class="n">header</span><span class="p">[</span><span class="s1">&#39;crval2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;x_min&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;x_step&#39;</span><span class="p">],</span>
                <span class="n">header</span><span class="p">[</span><span class="s1">&#39;cdelt2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;x_step&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Unsupported projection_type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span>
            <span class="k">raise</span> <span class="n">EngineOutputError</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">message</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">header</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.get_wave_pix"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.get_wave_pix">[docs]</a>    <span class="k">def</span> <span class="nf">get_wave_pix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mapping of wavelengths to pixels on the detector plane</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;wave_pix&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.get_fp_rate"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.get_fp_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_fp_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return scene flux at the focal plane in e-/s/pixel/micron (excludes background)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.get_bg_fp_rate"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.get_bg_fp_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_bg_fp_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate background in e-/s/pixel/micron at the focal plane. Also correct for any excess in predicted background</span>
<span class="sd">        if there are pupil losses in the PSF. (#2529)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bg_fp_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_plane_rate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ote_rate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="o">.</span><span class="n">mjy_pix</span><span class="p">))</span>
        <span class="n">wave_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_wave_range</span><span class="p">()</span>
        <span class="n">pupil_thru</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">psf_library</span><span class="o">.</span><span class="n">get_pupil_throughput</span><span class="p">(</span><span class="n">wave_range</span><span class="p">[</span><span class="s1">&#39;wmin&#39;</span><span class="p">],</span>
                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">instrument</span><span class="p">[</span>
                                                                                  <span class="s1">&#39;instrument&#39;</span><span class="p">],</span>
                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">instrument</span><span class="p">[</span>
                                                                                  <span class="s1">&#39;aperture&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">bg_fp_rate</span> <span class="o">*</span> <span class="n">pupil_thru</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.get_bg_pix_rate"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.get_bg_pix_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_bg_pix_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the background on the detector in e-/s/pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bg_pix_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_plus_bg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">bg_pix_rate</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.on_detector"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.on_detector">[docs]</a>    <span class="k">def</span> <span class="nf">on_detector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This will take the list of (pixel) rates and use them create a single detector frame. A single</span>
<span class="sd">        image will only have one rate in the list, but the IFUs will have n_slices. There may be other examples,</span>
<span class="sd">        such as different spectral orders for NIRISS. It is not yet clear how many different flavors there are, so</span>
<span class="sd">        this step may get refactored if it gets too complicated. Observing modes that only have one set of rates</span>
<span class="sd">        (imaging and single-slit spectroscopy, for instance) will still go through this, but the operation is trivial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aperture_sh</span> <span class="o">=</span> <span class="n">rate_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n_apertures</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rate_list</span><span class="p">)</span>
        <span class="n">detector_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">aperture_sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_apertures</span><span class="p">,</span> <span class="n">aperture_sh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">detector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">detector_shape</span><span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">rate</span> <span class="ow">in</span> <span class="n">rate_list</span><span class="p">:</span>
            <span class="n">detector</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">aperture_sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">aperture_sh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rate</span><span class="p">[</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">detector</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.get_pix_grid"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.get_pix_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_pix_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the coordinate grid of the detector plane</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;spec&#39;</span><span class="p">,</span> <span class="s1">&#39;slitless&#39;</span><span class="p">,</span> <span class="s1">&#39;multiorder&#39;</span><span class="p">):</span>
            <span class="n">nw</span> <span class="o">=</span> <span class="n">rate</span><span class="p">[</span><span class="s1">&#39;wave_pix&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispersion_axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                <span class="c1"># for slitless calculations, the dispersion axis is longer than the spectrum being dispersed</span>
                <span class="c1"># because the whole field of view is being dispersed. &#39;excess&#39; is the size of the FOV</span>
                <span class="c1"># and half will be to the left of the blue end of the spectrum and half to the right of the red end.</span>
                <span class="c1"># this is used to create the new spatial coordinate transform for the pixel image on the detector.</span>
                <span class="n">excess</span> <span class="o">=</span> <span class="n">rate</span><span class="p">[</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nw</span>
                <span class="n">pix_grid</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">IrregularGrid</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">col</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nw</span> <span class="o">+</span> <span class="n">excess</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">nw</span> <span class="o">+</span> <span class="n">excess</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">xsamp</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">excess</span> <span class="o">=</span> <span class="n">rate</span><span class="p">[</span><span class="s1">&#39;fp_pix&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">nw</span>
                <span class="n">pix_grid</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">IrregularGrid</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nw</span> <span class="o">+</span> <span class="n">excess</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">nw</span> <span class="o">+</span> <span class="n">excess</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ysamp</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">row</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">pix_grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EngineOutputError</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s2">&quot;Unsupported projection_type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.all_rates"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.all_rates">[docs]</a>    <span class="k">def</span> <span class="nf">all_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">add_extended_background</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate rates in e-/s/pixel/micron or e-/s/pixel given a flux cube in mJy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flux: ConvolvedSceneCube instance</span>
<span class="sd">            Convolved source flux cube with flux units in mJy</span>
<span class="sd">        add_extended_background: bool (default=False)</span>
<span class="sd">            Toggle for including extended background not contained within the flux cube</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        products: dict</span>
<span class="sd">            Dict of products produced by rate calculation.</span>
<span class="sd">                &#39;wave_pix&#39; - Mapping of wavelength to detector pixels</span>
<span class="sd">                &#39;ote&#39; - Source rate at the telescope aperture</span>
<span class="sd">                &#39;fp&#39; - Source rate at the focal plane in e-/s/pixel/micron</span>
<span class="sd">                &#39;fp_pix&#39; - Source rate per pixel</span>
<span class="sd">                &#39;fp_pix_no_ipc&#39; - Source rate per pixel excluding effects if inter-pixel capacitance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The source rate at the telescope aperture</span>
        <span class="n">ote_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ote_rate</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>

        <span class="c1"># The source rate at the focal plane in interacting photons/s/pixel/micron</span>
        <span class="n">fp_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_plane_rate</span><span class="p">(</span><span class="n">ote_rate</span><span class="p">)</span>

        <span class="c1"># the fp_pix_variance is the variance of the per-pixel electron rate and includes the chromatic effects</span>
        <span class="c1"># of quantum yield.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="c1"># The wavelength-integrated rate in e-/s/pixel, relevant for imagers</span>
            <span class="n">fp_pix_rate</span><span class="p">,</span> <span class="n">fp_pix_variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_rate</span><span class="p">(</span><span class="n">fp_rate</span><span class="p">)</span>
            <span class="n">wave_pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_eff</span><span class="p">(</span><span class="n">fp_rate</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="o">==</span> <span class="s1">&#39;spec&#39;</span><span class="p">:</span>
            <span class="c1"># The wavelength-integrated rate in e-/s/pixel, relevant for spectroscopy</span>
            <span class="n">wave_pix</span><span class="p">,</span> <span class="n">fp_pix_rate</span><span class="p">,</span> <span class="n">fp_pix_variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_rate</span><span class="p">(</span><span class="n">fp_rate</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;slitless&#39;</span><span class="p">,</span> <span class="s1">&#39;multiorder&#39;</span><span class="p">):</span>
            <span class="c1"># The wavelength-integrated rate in e-/s/pixel, relevant for slitless spectroscopy</span>
            <span class="n">wave_pix</span><span class="p">,</span> <span class="n">fp_pix_rate</span><span class="p">,</span> <span class="n">fp_pix_variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slitless_rate</span><span class="p">(</span>
                <span class="n">fp_rate</span><span class="p">,</span>
                <span class="n">add_extended_background</span><span class="o">=</span><span class="n">add_extended_background</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EngineOutputError</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s2">&quot;Unsupported projection_type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span><span class="p">)</span>

        <span class="c1"># Include IPC effects, if available and requested</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span><span class="p">[</span><span class="s1">&#39;ipc&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculation_config</span><span class="o">.</span><span class="n">effects</span><span class="p">[</span><span class="s1">&#39;ipc&#39;</span><span class="p">]:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_ipc_kernel</span><span class="p">()</span>
            <span class="n">fp_pix_rate_ipc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipc_convolve</span><span class="p">(</span><span class="n">fp_pix_rate</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fp_pix_rate_ipc</span> <span class="o">=</span> <span class="n">fp_pix_rate</span>

        <span class="c1"># fp_pix is the final product. Since there is no reason to</span>
        <span class="c1"># carry around the ipc label everywhere, we rename it here.</span>
        <span class="n">products</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;wave_pix&#39;</span><span class="p">:</span> <span class="n">wave_pix</span><span class="p">,</span>
            <span class="s1">&#39;ote&#39;</span><span class="p">:</span> <span class="n">ote_rate</span><span class="p">,</span>
            <span class="s1">&#39;fp&#39;</span><span class="p">:</span> <span class="n">fp_rate</span><span class="p">,</span>
            <span class="s1">&#39;fp_pix&#39;</span><span class="p">:</span> <span class="n">fp_pix_rate_ipc</span><span class="p">,</span>
            <span class="s1">&#39;fp_pix_no_ipc&#39;</span><span class="p">:</span> <span class="n">fp_pix_rate</span><span class="p">,</span>  <span class="c1"># this is for calculating saturation</span>
            <span class="s1">&#39;fp_pix_variance&#39;</span><span class="p">:</span> <span class="n">fp_pix_variance</span>  <span class="c1"># this is for calculating the detector noise</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">products</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.ote_rate"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.ote_rate">[docs]</a>    <span class="k">def</span> <span class="nf">ote_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate source rate in e-/s/pixel/micron at the telescope entrance aperture given</span>
<span class="sd">        a flux cube in mJy/pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># spectrum in mJy/pixel, wave in micron, f_lambda in photons/cm^2/s/micron</span>
        <span class="n">f_lambda</span> <span class="o">=</span> <span class="mf">1.5091905</span> <span class="o">*</span> <span class="p">(</span><span class="n">flux</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>
        <span class="n">ote_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">get_ote_eff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>
        <span class="n">coll_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">coll_area</span>
        <span class="n">a_lambda</span> <span class="o">=</span> <span class="n">coll_area</span> <span class="o">*</span> <span class="n">ote_int</span>
        <span class="c1"># e-/s/pixel/micron</span>
        <span class="n">ote_rate</span> <span class="o">=</span> <span class="n">f_lambda</span> <span class="o">*</span> <span class="n">a_lambda</span>
        <span class="k">return</span> <span class="n">ote_rate</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.focal_plane_rate"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.focal_plane_rate">[docs]</a>    <span class="k">def</span> <span class="nf">focal_plane_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the output from self.ote_rate() and multiplies it by the components</span>
<span class="sd">        of efficiency within the system and returns the source rate at the focal plane in</span>
<span class="sd">        e-/s/pixel/micron.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filter_eff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_filter_eff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>
        <span class="n">disperser_eff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_disperser_eff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>
        <span class="n">internal_eff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_internal_eff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>
        <span class="n">qe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_detector_qe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>

        <span class="n">fp_rate</span> <span class="o">=</span> <span class="n">rate</span> <span class="o">*</span> <span class="n">filter_eff</span> <span class="o">*</span> <span class="n">disperser_eff</span> <span class="o">*</span> <span class="n">internal_eff</span> <span class="o">*</span> <span class="n">qe</span>
        <span class="k">return</span> <span class="n">fp_rate</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.spec_rate"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.spec_rate">[docs]</a>    <span class="k">def</span> <span class="nf">spec_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For slitted spectrographs, calculate the detector signal by integrating</span>
<span class="sd">        along the dispersion direction of the cube (which is masked by a, by assumption,</span>
<span class="sd">        narrow slit). For slitless systems or slits wider than the PSF, the slitless_rate</span>
<span class="sd">        method should be used to preserve spatial information within the slit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        rate: numpy.ndarray</span>
<span class="sd">            Rate of photons interacting with detector as a function of model wavelength set</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        products: 3-element tuple of numpy.ndarrays</span>
<span class="sd">            first element - map of pixel to wavelength</span>
<span class="sd">            second element - electron rate per pixel</span>
<span class="sd">            third element - variance of electron rate per pixel</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">dispersion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_dispersion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>
        <span class="n">wave_pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_wave_pix</span><span class="p">()</span>
        <span class="n">wave_pix_trunc</span> <span class="o">=</span> <span class="n">wave_pix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">wave_pix</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                                                          <span class="n">wave_pix</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="o">.</span><span class="n">max</span><span class="p">()))]</span>

        <span class="c1"># Check that the source spectrum is actually inside the instrumental wavelength</span>
        <span class="c1"># coverage.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RangeError</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;wave and wave_pix do not overlap&#39;</span><span class="p">)</span>

        <span class="c1"># Check the dispersion axis to determine which axis to sum and interpolate over</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispersion_axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># We can simply sum over the dispersion direction. This is where we lose the spatial information within the aperture.</span>
        <span class="n">spec_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># And then scale to the dispersion function (pixel/micron) to transform</span>
        <span class="c1"># from e-/s/micron to e-/s/pixel.</span>
        <span class="n">spec_rate_pix</span> <span class="o">=</span> <span class="n">spec_rate</span> <span class="o">*</span> <span class="n">dispersion</span>

        <span class="c1"># but we are still sampled on the internal grid, so we have to interpolate to the pixel grid.</span>
        <span class="c1"># use kind=&#39;slinear&#39; since it&#39;s ~2x more memory efficient than &#39;linear&#39;. &#39;slinear&#39; uses different code path to</span>
        <span class="c1"># calculate the slopes.</span>
        <span class="n">int_spec_rate</span> <span class="o">=</span> <span class="n">sci_int</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="n">spec_rate_pix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;slinear&#39;</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">spec_rate_pix_sampled</span> <span class="o">=</span> <span class="n">int_spec_rate</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span>

        <span class="c1"># Handle a detector gap here by constructing a mask. If the current_instrument implements it,</span>
        <span class="c1"># it&#39;ll be a real mask array.  Otherwise it will simply be 1.0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">det_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">create_gap_mask</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span>

        <span class="c1"># this is the interacting photon rate in the detector with mask applied.</span>
        <span class="n">spec_rate_pix_sampled</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_mask</span>

        <span class="c1"># Add effects of non-unity quantum yields. For the spec projection, we assume that the quantum yield does not</span>
        <span class="c1"># change over a spectral element. Then we can just multiply the products by the relevant factors.</span>
        <span class="n">q_yield</span><span class="p">,</span> <span class="n">fano_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_quantum_yield</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span>

        <span class="c1"># convert the photon rate to electron rate by multiplying by the quantum yield which is a function of wavelength</span>
        <span class="n">spec_electron_rate_pix</span> <span class="o">=</span> <span class="n">spec_rate_pix_sampled</span> <span class="o">*</span> <span class="n">q_yield</span>

        <span class="c1"># to meet IDT expectations, some instruments require a possibly chromatic fudge factor to be applied</span>
        <span class="c1"># to the per-pixel electron rate variance.</span>
        <span class="n">var_fudge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_variance_fudge</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span>

        <span class="c1"># the variance in the electron rate, Ve, is also scaled by the quantum yield plus a fano factor which is</span>
        <span class="c1"># analytic in the simple 1 or 2 electron case: Ve = (qy + fano) * Re.  since Re is the photon rate</span>
        <span class="c1"># scaled by the quantum yield, Re = qy * Rp, we get: Ve = qy * (qy + fano) * Rp</span>
        <span class="n">spec_electron_variance_pix</span> <span class="o">=</span> <span class="n">spec_rate_pix_sampled</span> <span class="o">*</span> <span class="n">q_yield</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yield</span> <span class="o">+</span> <span class="n">fano_factor</span><span class="p">)</span> <span class="o">*</span> <span class="n">var_fudge</span>
        <span class="n">products</span> <span class="o">=</span> <span class="n">wave_pix_trunc</span><span class="p">,</span> <span class="n">spec_electron_rate_pix</span><span class="p">,</span> <span class="n">spec_electron_variance_pix</span>

        <span class="k">return</span> <span class="n">products</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.image_rate"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.image_rate">[docs]</a>    <span class="k">def</span> <span class="nf">image_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the electron rate for imaging modes by integrating along</span>
<span class="sd">        the wavelength direction of the cube.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        rate: numpy.ndarray</span>
<span class="sd">            Rate of photons interacting with detector as a function of model wavelength set</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        products: 2-element tuple of numpy.ndarrays</span>
<span class="sd">            first element - electron rate per pixel</span>
<span class="sd">            second element - variance of electron rate per pixel</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">q_yield</span><span class="p">,</span> <span class="n">fano_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_quantum_yield</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>

        <span class="c1"># convert the photon rate to electron rate by multiplying by the quantum yield which is a function of wavelength</span>
        <span class="n">electron_rate_pix</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">rate</span> <span class="o">*</span> <span class="n">q_yield</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>

        <span class="c1"># to meet IDT expectations, some instruments require a possibly chromatic fudge factor to be applied</span>
        <span class="c1"># to the per-pixel electron rate variance.</span>
        <span class="n">var_fudge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_variance_fudge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>

        <span class="c1"># the variance in the electron rate, Ve, is also scaled by the quantum yield plus a fano factor which is</span>
        <span class="c1"># analytic in the simple 1 or 2 electron case: Ve = (qy + fano) * Re.  since Re is the photon rate</span>
        <span class="c1"># scaled by the quantum yield, Re = qy * Rp, we get: Ve = qy * (qy + fano) * Rp</span>
        <span class="n">electron_variance_pix</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">rate</span> <span class="o">*</span> <span class="n">q_yield</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yield</span> <span class="o">+</span> <span class="n">fano_factor</span><span class="p">)</span> <span class="o">*</span> <span class="n">var_fudge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>

        <span class="n">products</span> <span class="o">=</span> <span class="n">electron_rate_pix</span><span class="p">,</span> <span class="n">electron_variance_pix</span>

        <span class="k">return</span> <span class="n">products</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.slitless_rate"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.slitless_rate">[docs]</a>    <span class="k">def</span> <span class="nf">slitless_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">add_extended_background</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the detector rates for slitless modes. Here we retain all spatial information and build</span>
<span class="sd">        up the detector plane by shifting and coadding the frames from the convolved flux cube. Also need to handle</span>
<span class="sd">        and add background that comes from outside the flux cube, but needs to be accounted for.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rate: 3D numpy.ndarray</span>
<span class="sd">            Cube containing the flux rate at the focal plane</span>
<span class="sd">        add_extended_background: bool (default: True)</span>
<span class="sd">            Toggle for including extended background not contained within the flux cube</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        products: 2 entry tuple</span>
<span class="sd">            wave_pix: 1D numpy.ndarray containing wavelength to pixel mapping on the detector plane</span>
<span class="sd">            spec_rate: 2D numpy.ndarray of detector count rates</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">wave_pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_wave_pix</span><span class="p">()</span>
        <span class="n">wave_subs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">wave_pix</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                <span class="n">wave_pix</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">wave_pix_trunc</span> <span class="o">=</span> <span class="n">wave_pix</span><span class="p">[</span><span class="n">wave_subs</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RangeError</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;wave and wave_pix do not overlap&#39;</span><span class="p">)</span>

        <span class="n">dispersion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_dispersion</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_trace</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span>

        <span class="n">q_yield</span><span class="p">,</span> <span class="n">fano_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_quantum_yield</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span>
        <span class="c1"># if we kind=&#39;slinear&#39; since it&#39;s ~2x more memory efficient than &#39;linear&#39;. &#39;slinear&#39; uses different code</span>
        <span class="c1"># path to calculate the slopes. However, slinear is *much* slower, so it is a tradeoff. Also lowering the</span>
        <span class="c1"># rate type to float32 to conserve memory.</span>
        <span class="n">int_rate_pix</span> <span class="o">=</span> <span class="n">sci_int</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="n">rate</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;same_kind&#39;</span><span class="p">),</span>
                                        <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">rate_pix</span> <span class="o">=</span> <span class="n">int_rate_pix</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span>

        <span class="c1"># convert the photon rate to electron rate by multiplying by the quantum yield which is a function of wavelength</span>
        <span class="n">electron_rate_pix</span> <span class="o">=</span> <span class="n">rate_pix</span> <span class="o">*</span> <span class="n">q_yield</span>

        <span class="c1"># to meet IDT expectations, some instruments require a possibly chromatic fudge factor to be applied</span>
        <span class="c1"># to the per-pixel electron rate variance.</span>
        <span class="n">var_fudge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">get_variance_fudge</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span>

        <span class="c1"># the variance in the electron rate, Ve, is also scaled by the quantum yield plus a fano factor which is</span>
        <span class="c1"># analytic in the simple 1 or 2 electron case: Ve = (qy + fano) * Re.  since Re is the photon rate</span>
        <span class="c1"># scaled by the quantum yield, Re = qy * Rp, we get: Ve = qy * (qy + fano) * Rp</span>
        <span class="n">electron_variance_pix</span> <span class="o">=</span> <span class="n">rate_pix</span> <span class="o">*</span> <span class="n">q_yield</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yield</span> <span class="o">+</span> <span class="n">fano_factor</span><span class="p">)</span> <span class="o">*</span> <span class="n">var_fudge</span>

        <span class="c1"># interpolate the background onto the pixel spacing</span>
        <span class="n">int_bg_fp_rate</span> <span class="o">=</span> <span class="n">sci_int</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bg_fp_rate</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;same_kind&#39;</span><span class="p">),</span>
                                          <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">bg_fp_rate_pix</span> <span class="o">=</span> <span class="n">int_bg_fp_rate</span><span class="p">(</span><span class="n">wave_pix_trunc</span><span class="p">)</span>

        <span class="c1"># calculate electron rate and variance due to background</span>
        <span class="n">bg_electron_rate</span> <span class="o">=</span> <span class="n">bg_fp_rate_pix</span> <span class="o">*</span> <span class="n">q_yield</span>
        <span class="n">bg_electron_variance</span> <span class="o">=</span> <span class="n">bg_fp_rate_pix</span> <span class="o">*</span> <span class="n">q_yield</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yield</span> <span class="o">+</span> <span class="n">fano_factor</span><span class="p">)</span> <span class="o">*</span> <span class="n">var_fudge</span>

        <span class="c1"># The first part of this code is meant to add the PSF images from the convolved scene cube along either the x</span>
        <span class="c1"># or y axis depending on the dispersion axis, optionally following the path of a spectral trace (currently used</span>
        <span class="c1"># only for SOSS mode). The psfs will be added to all locations within the resolution element.</span>
        <span class="c1">#</span>
        <span class="c1"># Because, in slitless modes, the disperser is dispersing light coming in from everywhere in the pupil plane,</span>
        <span class="c1"># every part of the detector should have a contribution from every wavelength of light (from both orders, for</span>
        <span class="c1"># SOSS mode). The add_extended_background statement does that - it fills every pixel up to i, and after</span>
        <span class="c1"># i+rate_pix.shape[1], with the same background that comes baked into the rate_pix images thanks to the</span>
        <span class="c1"># AdvancedPSF functions that create the convolved scene cube.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_scene</span><span class="p">:</span>
            <span class="c1"># if we have an explicitly empty scene, we&#39;re doing a background-only order calculation and don&#39;t need to</span>
            <span class="c1"># even pretend to disperse the spectrum - CombinedSignal will handle padding it to match the interesting</span>
            <span class="c1"># order(s) and this way there will be no need to trim.</span>
            <span class="n">spec_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">spec_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spec_shape</span><span class="p">)</span>
            <span class="n">spec_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spec_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">add_extended_background</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dispersion</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">spec_rate</span> <span class="o">+=</span> <span class="n">bg_electron_rate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">spec_variance</span> <span class="o">+=</span> <span class="n">bg_electron_variance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if the scene is data</span>
            <span class="c1"># dispersion_axis tells us whether we need to sum the planes of the cube horizontally</span>
            <span class="c1"># or vertically on the detector plane.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispersion_axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                <span class="n">spec_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">spec_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spec_shape</span><span class="p">)</span>
                <span class="n">spec_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spec_shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dispersion</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># Background not yet completely added. Make sure there is a trace shift to be done so that we</span>
                    <span class="c1"># don&#39;t make an expensive call to shift() if we don&#39;t have to. Use mode=&#39;nearest&#39; to fill in new</span>
                    <span class="c1"># pixels with background when image is shifted.</span>
                    <span class="k">if</span> <span class="n">trace</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">spec_rate</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">(</span>
                            <span class="n">electron_rate_pix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">],</span>
                            <span class="n">shift</span><span class="o">=</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
                            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                            <span class="n">order</span><span class="o">=</span><span class="mi">1</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">spec_variance</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">(</span>
                            <span class="n">electron_variance_pix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">],</span>
                            <span class="n">shift</span><span class="o">=</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
                            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                            <span class="n">order</span><span class="o">=</span><span class="mi">1</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">spec_rate</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">electron_rate_pix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">spec_variance</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">electron_variance_pix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                    <span class="c1"># Adding background to all other pixels, unless we are asked not to.</span>
                    <span class="k">if</span> <span class="n">add_extended_background</span><span class="p">:</span>
                        <span class="n">spec_rate</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bg_electron_rate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">spec_rate</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">+=</span> <span class="n">bg_electron_rate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">spec_variance</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bg_electron_variance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">spec_variance</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">+=</span> <span class="n">bg_electron_variance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># if the dispersion is on the y axis</span>
                <span class="n">spec_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">spec_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spec_shape</span><span class="p">)</span>
                <span class="n">spec_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spec_shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dispersion</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># Background not yet completely added. Make sure there is a trace shift to be done so that we</span>
                    <span class="c1"># don&#39;t make an expensive call to shift() if we don&#39;t have to. Use mode=&#39;nearest&#39; to fill in new</span>
                    <span class="c1"># pixels with background when image is shifted.</span>
                    <span class="k">if</span> <span class="n">trace</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">spec_rate</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">(</span>
                            <span class="n">electron_rate_pix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">],</span>
                            <span class="n">shift</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                            <span class="n">order</span><span class="o">=</span><span class="mi">1</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">spec_variance</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">(</span>
                            <span class="n">electron_variance_pix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">],</span>
                            <span class="n">shift</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                            <span class="n">order</span><span class="o">=</span><span class="mi">1</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">spec_rate</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">electron_rate_pix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">spec_variance</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">electron_variance_pix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># Adding background to all other pixels, unless we are asked not to.</span>
                    <span class="k">if</span> <span class="n">add_extended_background</span><span class="p">:</span>
                        <span class="n">spec_rate</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">bg_electron_rate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">spec_rate</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">bg_electron_rate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">spec_variance</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">bg_electron_variance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">spec_variance</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">rate_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">bg_electron_variance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># dispersion_axis determines whether wavelength is the first or second axis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispersion_axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span> <span class="o">==</span> <span class="s1">&#39;multiorder&#39;</span><span class="p">:</span>
            <span class="n">products</span> <span class="o">=</span> <span class="n">wave_pix_trunc</span><span class="p">,</span> <span class="n">spec_rate</span><span class="p">,</span> <span class="n">spec_variance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if dispersion is along Y, wavelength increases bottom to top, but Y index increases top to bottom.</span>
            <span class="c1"># flip the Y axis to account for this.</span>
            <span class="n">products</span> <span class="o">=</span> <span class="n">wave_pix_trunc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">spec_rate</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">spec_variance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">products</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.wave_eff"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.wave_eff">[docs]</a>    <span class="k">def</span> <span class="nf">wave_eff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="n">rate_tot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rate_tot</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rate_tot</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">wave_eff</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wave_eff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">wave_eff_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">wave_eff</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">wave_eff_arr</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.get_projection_type"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.get_projection_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_projection_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_type</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.ipc_convolve"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.ipc_convolve">[docs]</a>    <span class="k">def</span> <span class="nf">ipc_convolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">kernel</span><span class="p">):</span>
        <span class="n">fp_pix_ipc</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>

        <span class="n">debug_utils</span><span class="o">.</span><span class="n">debugarrays</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="s1">&#39;etc3D&#39;</span><span class="p">,</span> <span class="s1">&#39;ipc_convolve&#39;</span><span class="p">,</span>
                                      <span class="p">{</span>
                                          <span class="s1">&#39;rate&#39;</span><span class="p">:</span> <span class="n">rate</span><span class="p">,</span>
                                          <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="n">kernel</span><span class="p">,</span>
                                          <span class="s1">&#39;fp_pix_ipc&#39;</span><span class="p">:</span> <span class="n">fp_pix_ipc</span><span class="p">,</span>
                                          <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;This is just a short, unnecessary description.&#39;</span>
                                      <span class="p">})</span>

        <span class="k">return</span> <span class="n">fp_pix_ipc</span></div>

<div class="viewcode-block" id="CoronagraphyDetectorSignal.get_saturation_mask"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.CoronagraphyDetectorSignal.get_saturation_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_saturation_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a numpy array indicating pixels with full saturation (2), partial saturation (1) and no saturation (0).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rate: None or 2D np.ndarray</span>
<span class="sd">            Detector plane rate image used to build saturation map from</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask: 2D np.ndarray</span>
<span class="sd">            Saturation mask image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_plus_bg</span>

        <span class="n">saturation_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">rate</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculation_config</span><span class="o">.</span><span class="n">effects</span><span class="p">[</span><span class="s1">&#39;saturation&#39;</span><span class="p">]:</span>
            <span class="n">fullwell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span><span class="p">[</span><span class="s1">&#39;fullwell&#39;</span><span class="p">]</span>
            <span class="n">exp_pars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">exposure_spec</span>
            <span class="n">unsat_ngroups</span> <span class="o">=</span> <span class="n">exp_pars</span><span class="o">.</span><span class="n">get_unsaturated_groups</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">fullwell</span><span class="p">)</span>
            <span class="n">ngroup</span> <span class="o">=</span> <span class="n">exp_pars</span><span class="o">.</span><span class="n">ngroup</span>

            <span class="n">saturation_mask</span><span class="p">[(</span><span class="n">unsat_ngroups</span> <span class="o">&lt;</span> <span class="n">ngroup</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">saturation_mask</span><span class="p">[(</span><span class="n">unsat_ngroups</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">saturation_mask</span></div>

    <span class="k">def</span> <span class="nf">_groups_before_sat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">fullwell</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix for Pandeia 1.2/1.3, since exposure spec doesn&#39;t have this in 1.2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exposure_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_instrument</span><span class="o">.</span><span class="n">exposure_spec</span>
        <span class="n">tfffr</span> <span class="o">=</span> <span class="n">exposure_spec</span><span class="o">.</span><span class="n">tfffr</span>
        <span class="n">nframe</span> <span class="o">=</span> <span class="n">exposure_spec</span><span class="o">.</span><span class="n">nframe</span>
        <span class="n">tframe</span> <span class="o">=</span> <span class="n">exposure_spec</span><span class="o">.</span><span class="n">tframe</span>
        <span class="n">nskip</span> <span class="o">=</span> <span class="n">exposure_spec</span><span class="o">.</span><span class="n">nskip</span>
        <span class="n">time_to_saturation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_pars</span><span class="p">[</span><span class="s1">&#39;fullwell&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">slope</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">slope</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">exposure_spec</span><span class="o">.</span><span class="n">det_type</span> <span class="o">==</span> <span class="s1">&#39;sias&#39;</span><span class="p">:</span>
            <span class="n">groups_before_sat</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_to_saturation</span> <span class="o">-</span> <span class="n">tfffr</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nframe</span> <span class="o">*</span> <span class="n">tframe</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">exposure_spec</span><span class="o">.</span><span class="n">det_type</span> <span class="o">==</span> <span class="s1">&#39;h2rg&#39;</span><span class="p">:</span>
            <span class="n">groups_before_sat</span> <span class="o">=</span> <span class="p">(((</span><span class="n">time_to_saturation</span> <span class="o">-</span> <span class="n">tfffr</span><span class="p">)</span> <span class="o">/</span> <span class="n">tframe</span><span class="p">)</span> <span class="o">-</span> <span class="n">nframe</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nframe</span> <span class="o">+</span> <span class="n">nskip</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown detector type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exposure_spec</span><span class="o">.</span><span class="n">det_type</span><span class="p">))</span>
        <span class="n">slice_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">groups_before_sat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">slice_group</span></div>



<div class="viewcode-block" id="SeparateTargetReferenceCoronagraphy"><a class="viewcode-back" href="../../api.html#pancake.pandeia_subclasses.SeparateTargetReferenceCoronagraphy">[docs]</a><span class="k">class</span> <span class="nc">SeparateTargetReferenceCoronagraphy</span><span class="p">(</span><span class="n">Coronagraphy</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This class is intended to override the cronography behaviour of requiring that the reference </span>
<span class="sd">    source be included in the same calculation template as the observation source.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">_create_weight_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">my_detector_signal_list</span><span class="p">,</span> <span class="n">my_detector_noise_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This private method creates the weight matrix, a_ij, used for the strategy sum. It gets overridden</span>
<span class="sd">        in each strategy. In this case, it applies all weight to the first (and only) target. As such, it</span>
<span class="sd">        deliberately uses the weight matrix creation from the ImagingApPhot class</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_detector_signal_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;This Strategy Configuration is intended for separate Target, Reference, and Unocculted Source observations, so only one signal is supported.&#39;</span>
            <span class="k">raise</span> <span class="n">UnsupportedError</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">message</span><span class="p">)</span>

        <span class="n">my_detector_signal</span> <span class="o">=</span> <span class="n">my_detector_signal_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">aperture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aperture_size</span>
        <span class="n">annulus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sky_annulus</span>

        <span class="c1"># pass target_xy to Signal.grid.dist() to offset the target position</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">my_detector_signal</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">xcen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ycen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># sky_subs only takes into account whole pixels which is sufficient for the sky estimation</span>
        <span class="c1"># region and for the sanity checking we need to do. however, we need to be more exact for the source extraction</span>
        <span class="c1"># region. photutils.geometry provides routines to do this either via subsampling or exact geometric</span>
        <span class="c1"># calculation. the exact method is slower, but for the sizes of regions we deal with in the ETC it is not noticeable.</span>
        <span class="n">sky_subs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">annulus</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">annulus</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">n_sky</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sky_subs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># generate the source extraction region mask.</span>
        <span class="n">src_region</span> <span class="o">=</span> <span class="n">my_detector_signal</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">circular_mask</span><span class="p">(</span>
            <span class="n">aperture</span><span class="p">,</span>
            <span class="n">xoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">yoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">use_exact</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_exact</span><span class="p">,</span>
            <span class="n">subsampling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subsampling</span>
        <span class="p">)</span>

        <span class="c1"># the src_region mask values are the fraction of the pixel subtended by the aperture so</span>
        <span class="c1"># in the range 0.0 to 1.0 inclusive.  the effective number of pixels in the aperture is</span>
        <span class="c1"># then the sum of this mask.</span>
        <span class="n">n_aper</span> <span class="o">=</span> <span class="n">src_region</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># do some more sanity checks to make sure the target and background regions are configured as expected</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_circular_aperture_limits</span><span class="p">(</span><span class="n">src_region</span><span class="p">,</span> <span class="n">sky_subs</span><span class="p">,</span> <span class="n">my_detector_signal</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">aperture</span><span class="p">,</span> <span class="n">annulus</span><span class="p">)</span>

        <span class="n">weight_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">src_region</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">background_subtraction</span><span class="p">:</span>
            <span class="n">weight_matrix</span><span class="p">[</span><span class="n">sky_subs</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">n_aper</span> <span class="o">/</span> <span class="n">n_sky</span>

        <span class="c1"># The method also returns a list of &#39;products&#39;: subscripts of the weight matrix that is non-zero.</span>
        <span class="c1"># This can also be a list if the strategy returns more than one product (such a spectrum over a</span>
        <span class="c1"># number of wavelengths).</span>
        <span class="n">product_subscript</span> <span class="o">=</span> <span class="n">weight_matrix</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

        <span class="c1"># The subscripts returned from a matrix contain a redundant dimension. This removes it.</span>
        <span class="c1"># Note that this is not how matrix indexing is formally constructed, but it enforces a rule</span>
        <span class="c1"># that product subscripts should always be tuples or regular ndarrays.</span>
        <span class="n">product_subscript</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">product_subscript</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">product_subscript</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">weight_matrix</span><span class="p">,</span> <span class="p">[</span><span class="n">product_subscript</span><span class="p">]</span></div>
    
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Aarynn Carter.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>