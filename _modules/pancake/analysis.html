

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pancake.analysis &mdash; PanCAKE 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> PanCAKE
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Welcome to PanCAKEâ€™s documentation!</a></li>
</ul>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basic_tutorial.html">Basic Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scene.html">Astrophysical Scene Constuction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sequence.html">Observational Sequence Constuction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../simulation.html">Simulation Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../postprocessing.html">Postprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PanCAKE</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../pancake.html">pancake</a> &raquo;</li>
        
      <li>pancake.analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pancake.analysis</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> 
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span><span class="p">,</span> <span class="n">interp2d</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">t</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">read_coronagraph_transmission</span><span class="p">,</span> <span class="n">determine_bar_offset</span>
<span class="kn">import</span> <span class="nn">pyklip.klip</span> 
<span class="kn">import</span> <span class="nn">pyklip.instruments.Instrument</span> <span class="k">as</span> <span class="nn">Instrument</span>
<span class="kn">import</span> <span class="nn">pyklip.parallelized</span> <span class="k">as</span> <span class="nn">parallelized</span>
<span class="kn">import</span> <span class="nn">pyklip.rdi</span> <span class="k">as</span> <span class="nn">rdi</span>
<span class="kn">import</span> <span class="nn">pyklip.fakes</span> <span class="k">as</span> <span class="nn">fakes</span>


<span class="c1"># Getting erros when trying to use multiprocessing with pyKLIP</span>
<span class="c1"># Disable using the below</span>
<div class="viewcode-block" id="debug"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.debug">[docs]</a><span class="n">parallelized</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">True</span></div>

<span class="c1">##############################</span>
<span class="c1"># DISCLAIMER </span>
<span class="c1"># Many functions in this file are heavily inspired by and adapted from the work of Jea Adams on ExoPix.</span>
<span class="c1"># https://exopix.readthedocs.io/en/latest/</span>
<span class="c1">##############################</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
<div class="viewcode-block" id="enable_runtime_warnings"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.enable_runtime_warnings">[docs]</a><span class="k">def</span> <span class="nf">enable_runtime_warnings</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function to toggle on/off RuntimeWarning&#39;s. Many of these do not impact the functionality of the code</span>
<span class="sd">	and therefore can be safely ignored for the vast majority of user cases. As a result, this function is</span>
<span class="sd">	immediately called a few lines above. </span>

<span class="sd">	Parameters</span>
<span class="sd">		state : bool</span>
<span class="sd">			Whether the RuntimeWarning&#39;s should be enabled (True), or disabled ( False).</span>
<span class="sd">	Returns:</span>
<span class="sd">		None</span>
<span class="sd">	&quot;&quot;&quot;</span> 
	<span class="k">if</span> <span class="n">state</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
		<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;always&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">state</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
		<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Runtime Warnings can only be enabled/disabled with a boolean True/False input.&#39;</span><span class="p">)</span></div>

<span class="c1">#### Impossible to pass the mask argument into pyKLIP, to use with inject_planet() function must use the functools partial function to set the mask variable</span>
<div class="viewcode-block" id="transmission_corrected"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.transmission_corrected">[docs]</a><span class="k">def</span> <span class="nf">transmission_corrected</span><span class="p">(</span><span class="n">input_stamp</span><span class="p">,</span> <span class="n">input_dx</span><span class="p">,</span> <span class="n">input_dy</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;multiply&#39;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function to apply a 2-dimensional JWST coronagraphic transmission map to an input image.</span>

<span class="sd">	Parameters</span>
<span class="sd">		input_stamp : 2D ndarray</span>
<span class="sd">			Input image, should have dimensions equal to or smaller than the array for the</span>
<span class="sd">			coronagraphic transmission map.</span>
<span class="sd">		input_dx : 2D ndarray</span>
<span class="sd">			Array of X pixel offsets for each element in the array relative to the central pixel of the simulation. </span>
<span class="sd">		input_dy : 2D ndarray</span>
<span class="sd">			Array of Y pixel offsets for each element in the array relative to the central pixel of the simulation. 	</span>
<span class="sd">		filt : str</span>
<span class="sd">			JWST filter string, used to obtain offsets for the NIRCam bar masks. </span>
<span class="sd">		mask : str</span>
<span class="sd">			JWST coronagraphic mask string, used to identify which transmission map to apply.</span>
<span class="sd">		mode : str</span>
<span class="sd">			Whether to &#39;multiply&#39; or &#39;divide&#39; the input stamp by the transmission map. </span>
<span class="sd">	Returns</span>
<span class="sd">		output_stamp : 2D ndarray</span>
<span class="sd">			Equivalent to the input_stamp following the application of the transmission map. </span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1">##### Get the x- and y- dimension for the input image</span>
	<span class="n">input_x</span><span class="p">,</span> <span class="n">input_y</span> <span class="o">=</span> <span class="n">input_stamp</span><span class="o">.</span><span class="n">shape</span> 

	<span class="c1">##### Read in the transmission array for the mask we are using</span>
	<span class="n">transmission</span> <span class="o">=</span> <span class="n">read_coronagraph_transmission</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

	<span class="c1">##### If we are using a NIRCam bar mask, the center of the input images will correspond to different </span>
	<span class="c1">##### locations in the transmission map dependent on the filter used.</span>
	<span class="c1">#### NOTE: AS OF 14/06/2021, these offsets are not always correct.</span>
	<span class="k">if</span> <span class="n">mask</span> <span class="o">==</span> <span class="s1">&#39;MASKSWB&#39;</span><span class="p">:</span>
		<span class="n">xoff</span> <span class="o">=</span> <span class="n">determine_bar_offset</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.0311</span> <span class="c1">#Make sure to convert from arcsec to pixels</span>
		<span class="n">yoff</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">elif</span> <span class="n">mask</span> <span class="o">==</span> <span class="s1">&#39;MASKLWB&#39;</span><span class="p">:</span>
		<span class="c1">#Important to adjust the sign for the LWB as things are reversed in Pandeia</span>
		<span class="n">xoff</span> <span class="o">=</span> <span class="o">-</span><span class="n">determine_bar_offset</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.063</span> <span class="c1">#Make sure to convert from arcsec to pixels</span>
		<span class="n">yoff</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">xoff</span><span class="p">,</span> <span class="n">yoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

	<span class="c1">##### Now need to get the portion of the transmission map that corresponds to the input stamp image. </span>
	<span class="n">trans_x</span><span class="p">,</span> <span class="n">trans_y</span> <span class="o">=</span> <span class="n">transmission</span><span class="o">.</span><span class="n">shape</span>
	<span class="n">trans_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">trans_x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">trans_x</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> 
	<span class="n">trans_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">trans_y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">trans_y</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> 

	<span class="c1">#Create interpolation for the tranmission map we are using </span>
	<span class="n">trans_interp</span>  <span class="o">=</span> <span class="n">interp2d</span><span class="p">(</span><span class="n">trans_dx</span><span class="p">,</span> <span class="n">trans_dy</span><span class="p">,</span> <span class="n">transmission</span><span class="p">)</span>

	<span class="c1">#Use the interpolation to identify the transmission at each pixel in the input image. </span>
	<span class="n">transmission_stamp</span> <span class="o">=</span> <span class="n">trans_interp</span><span class="p">(</span><span class="n">input_dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">xoff</span><span class="p">,</span> <span class="n">input_dy</span><span class="o">.</span><span class="n">transpose</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span> <span class="n">yoff</span><span class="p">)</span>

	<span class="c1">##### Apply the transmission, dependent on which mode has been selected</span>
	<span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;multiply&#39;</span><span class="p">:</span>
		<span class="n">output_stamp</span> <span class="o">=</span> <span class="n">input_stamp</span> <span class="o">*</span> <span class="n">transmission_stamp</span>
	<span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;divide&#39;</span><span class="p">:</span>
		<span class="n">output_stamp</span> <span class="o">=</span> <span class="n">input_stamp</span> <span class="o">/</span> <span class="n">transmission_stamp</span>

	<span class="k">return</span> <span class="n">output_stamp</span></div>

<div class="viewcode-block" id="identify_primary_sources"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.identify_primary_sources">[docs]</a><span class="k">def</span> <span class="nf">identify_primary_sources</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">references</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_primary_source</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">reference_primary_sources</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function to identify, or assume, the primary sources (i.e. central &#39;stars&#39;) of output PanCAKE simulation results. </span>

<span class="sd">	Parameters</span>
<span class="sd">		pancake_results : HDUList</span>
<span class="sd">			Simulated results as returned by pancake.sequence.Sequence().run()</span>
<span class="sd">		target : str</span>
<span class="sd">			The provided string name for the target scene in the observation sequence. </span>
<span class="sd">		references : str / list of strings / NoneType</span>
<span class="sd">			The provided string name(s) for the reference scene(s) in the observations sequence, if any.</span>
<span class="sd">		target_primary_source : str</span>
<span class="sd">			Desired primary source to use for the target scene, or &#39;default&#39; to assume primary source. </span>
<span class="sd">		reference_primary_sources : str / list of strings</span>
<span class="sd">			Desired primary source(s) to use for the reference scene(s), or &#39;default&#39; to assume primary source(s).</span>
<span class="sd">	Returns</span>
<span class="sd">		primary_sources : list of strings</span>
<span class="sd">			List of the primary source(s), where the source in the &#39;0&#39; index always corresponds to the target scene. </span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1">#Get all of the observations names for this simulation</span>
	<span class="n">obs_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">pancake_results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;EXTNAME&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">))]</span>
	<span class="n">scene_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">obs_names</span><span class="p">]))</span>

	<span class="c1"># If references is None, just set references to an empty array</span>
	<span class="k">if</span> <span class="n">references</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">references</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="c1"># Initialise array</span>
	<span class="n">primary_sources</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">scene</span> <span class="ow">in</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">+</span><span class="n">references</span><span class="p">:</span> 
		<span class="c1"># Grab only the observations of this scene</span>
		<span class="n">match_obs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">obs_names</span> <span class="k">if</span> <span class="s1">&#39;:&#39;</span><span class="o">+</span><span class="n">scene</span><span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">match_obs</span><span class="p">:</span>
			<span class="c1">#There were no matches to the input target/reference string</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find specified scene &#39;</span><span class="si">{}</span><span class="s2">&#39; within simulated results. Possible scenes include: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">scene_names</span><span class="p">)))</span>

		<span class="c1"># If error is not raised, we have a match for this scene. </span>
		<span class="c1"># Doesn&#39;t really matter which precise observation we use, so just use the first one. </span>
		<span class="n">example_header</span> <span class="o">=</span> <span class="n">pancake_results</span><span class="p">[</span><span class="n">match_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">header</span>
		<span class="n">num_sources</span> <span class="o">=</span> <span class="n">example_header</span><span class="p">[</span><span class="s1">&#39;NSOURCES&#39;</span><span class="p">]</span>
		<span class="n">all_sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">example_header</span><span class="p">[</span><span class="s1">&#39;SOURCE</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sources</span><span class="p">)]</span>
		<span class="k">if</span> <span class="n">scene</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">and</span> <span class="n">target_primary_source</span> <span class="o">!=</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
			<span class="c1"># We need to use the user provided target primary source</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">target_primary_source</span> <span class="ow">in</span> <span class="n">all_sources</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specified source &#39;</span><span class="si">{}</span><span class="s2">&#39; for target scene &#39;</span><span class="si">{}</span><span class="s2">&#39; not found. Available sources are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_primary_source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">all_sources</span><span class="p">)))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">primary_source</span> <span class="o">=</span> <span class="n">target_primary_source</span>
		<span class="k">elif</span> <span class="n">scene</span> <span class="ow">in</span> <span class="n">references</span> <span class="ow">and</span> <span class="n">reference_primary_sources</span> <span class="o">!=</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
			<span class="c1"># We need to use the user provided reference primary source</span>
			<span class="n">ref_source</span> <span class="o">=</span> <span class="n">reference_primary_sources</span><span class="p">[</span><span class="n">references</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">scene</span><span class="p">)]</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">ref_source</span> <span class="ow">in</span> <span class="n">all_sources</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specified source &#39;</span><span class="si">{}</span><span class="s2">&#39; for reference scene &#39;</span><span class="si">{}</span><span class="s2">&#39; not found. Available sources are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_primary_source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">all_sources</span><span class="p">)))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">primary_source</span> <span class="o">=</span> <span class="n">ref_source</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># We choose a default primary source of &#39;SOURCE1&#39;</span>
			<span class="n">primary_source</span> <span class="o">=</span> <span class="n">example_header</span><span class="p">[</span><span class="s1">&#39;SOURCE1&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">num_sources</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
				<span class="c1"># Warn the user which source we picked. </span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Assuming primary source &quot;</span><span class="si">{}</span><span class="s1">&quot; for scene &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">primary_source</span><span class="p">,</span> <span class="n">scene</span><span class="p">))</span>

		<span class="c1">#Append primary source to array. Eventual order will be the target primary, then the reference primaries in the order they were provided. </span>
		<span class="n">primary_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">primary_source</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">primary_sources</span></div>

<div class="viewcode-block" id="extract_simulated_images"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.extract_simulated_images">[docs]</a><span class="k">def</span> <span class="nf">extract_simulated_images</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">,</span> <span class="n">observations</span><span class="p">,</span> <span class="n">primary_sources</span><span class="p">,</span> <span class="n">all_rolls</span><span class="p">,</span> <span class="n">references</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extract_offaxis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function to extract a subset of simulated images from the output of a PanCAKE simulation into a more flexible format. </span>
<span class="sd">	</span>
<span class="sd">	Parameters</span>
<span class="sd">		pancake_results : HDUList</span>
<span class="sd">			Simulated results as returned by pancake.sequence.Sequence().run()</span>
<span class="sd">		observations : list of strings</span>
<span class="sd">			List of observation strings that correspond to extension names in the pancake_results HDUList</span>
<span class="sd">		primary_sources : list of strings</span>
<span class="sd">			List of the primary source(s) as obtained by identify_primary_sources</span>
<span class="sd">		all_rolls : list of ints / floats</span>
<span class="sd">			Which PA roll images to be extracted</span>
<span class="sd">		references : str / list of strings / NoneType</span>
<span class="sd">			The provided string name(s) for the reference scene(s) in the observations sequence, if any. Can</span>
<span class="sd">			not be used in conjunction with retrieving simulated target images. </span>
<span class="sd">		extract_offaxis : bool</span>
<span class="sd">			Boolean choice of whether to extract offaxis images or not</span>
<span class="sd">		filename_prefix : str</span>
<span class="sd">			Simple prefix string used to assign a unique name to each simulated image.</span>
<span class="sd">	Returns</span>
<span class="sd">		extracted : dict</span>
<span class="sd">			Dictionary containing all requested images, their roll angles, center points, assigned filenames, and</span>
<span class="sd">			if requested, a 20x20 pixel offaxis PSF stamp image and its peak flux.  </span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="c1">##### Create placeholder variables to append to / adjust later. </span>
	<span class="n">images</span><span class="p">,</span> <span class="n">pas</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">filenames</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span> 
	<span class="n">offaxis_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span> 
	<span class="n">offaxis_psf_stamp</span><span class="p">,</span> <span class="n">offaxis_peak_flux</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span> 
	
	<span class="c1">##### Loop over the requested observations. </span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">observations</span><span class="p">):</span> 
		<span class="c1">#Extract data and header informatino</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">pancake_results</span><span class="p">[</span><span class="n">obs</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">pancake_results</span><span class="p">[</span><span class="n">obs</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
		
		<span class="n">rollang</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="s1">&#39;ROLLANG&#39;</span><span class="p">]</span> <span class="c1"># PA roll angle</span>
		<span class="n">pixel_scale</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="s1">&#39;PIXSCALE&#39;</span><span class="p">]</span> <span class="c1"># Pixel scale for this observations</span>
		
		<span class="n">filt</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">wavelength</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">d+&#39;</span><span class="p">,</span> <span class="n">filt</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1e8</span>
		<span class="n">lambda_d_arcsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">wavelength</span> <span class="o">/</span> <span class="mf">6.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3600</span>
		<span class="n">lambda_d_pixel</span> <span class="o">=</span> <span class="n">lambda_d_arcsec</span> <span class="o">/</span> <span class="n">pixel_scale</span> 

		<span class="n">source_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SOURCE</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">head</span><span class="p">[</span><span class="s1">&#39;NSOURCES&#39;</span><span class="p">])]</span>
		<span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">head</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">source_keys</span><span class="p">]</span> <span class="c1"># Names of the sources in this observation. </span>

		<span class="k">if</span> <span class="n">references</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="c1"># This extraction is for target observations.</span>
			<span class="n">primary_source_id</span> <span class="o">=</span> <span class="n">source_keys</span><span class="p">[</span><span class="n">sources</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">primary_sources</span><span class="p">[</span><span class="mi">0</span><span class="p">])][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">rolls</span> <span class="o">=</span> <span class="n">all_rolls</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># This extraction is for multiple different reference observations, need to change properties based on specific obs</span>
			<span class="n">ref_scene_index</span> <span class="o">=</span> <span class="n">references</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">primary_source_id</span> <span class="o">=</span> <span class="n">source_keys</span><span class="p">[</span><span class="n">sources</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">primary_sources</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">ref_scene_index</span><span class="p">])][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">rolls</span> <span class="o">=</span> <span class="n">all_rolls</span><span class="p">[</span><span class="n">ref_scene_index</span><span class="p">]</span> <span class="c1"># Just get the rolls for this particular scene. </span>

		<span class="c1"># Loop over the PA rolls requested. </span>
		<span class="k">if</span> <span class="n">rollang</span> <span class="ow">in</span> <span class="n">rolls</span><span class="p">:</span> 
			<span class="c1"># Loop over each simulated image for this observation. </span>
			<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
					<span class="c1">#Final index is for offaxis images, all indexes before this are what we&#39;re interested in. </span>

					<span class="c1"># Grab X and Y offsets of the primary source.</span>
					<span class="c1"># NOTE: Y offset must have its sign reversed due to differences between Pandeia scene construction and analysis of the image arrays</span>
					<span class="n">xoff</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="s1">&#39;S</span><span class="si">{}</span><span class="s1">XOFF</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">primary_source_id</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">/</span> <span class="n">pixel_scale</span> 
					<span class="n">yoff</span> <span class="o">=</span> <span class="o">-</span><span class="n">head</span><span class="p">[</span><span class="s1">&#39;S</span><span class="si">{}</span><span class="s1">YOFF</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">primary_source_id</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">/</span> <span class="n">pixel_scale</span>
					<span class="n">raw_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

					<span class="c1"># Append calculated values. </span>
					<span class="n">images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
					<span class="n">pas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rollang</span><span class="p">)</span>
					<span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">raw_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">xoff</span><span class="p">,</span> <span class="n">raw_centers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">yoff</span><span class="p">])</span>
					<span class="n">filenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename_prefix</span><span class="o">+</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="c1">#This is an unocculted off axis image. </span>
					<span class="k">if</span> <span class="n">extract_offaxis</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">offaxis_image</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
						<span class="c1">#Doesn&#39;t matter too much which specific image we use, just need an example. </span>
						<span class="c1"># NOTE: Y offset must have its sign reversed due to differences between Pandeia scene construction and analysis of the image arrays</span>
						<span class="n">offaxis_image</span> <span class="o">=</span> <span class="n">image</span>
						<span class="n">offaxis_xoff</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="s1">&#39;S</span><span class="si">{}</span><span class="s1">OFFAX&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">primary_source_id</span><span class="p">)]</span><span class="o">/</span><span class="n">pixel_scale</span>
						<span class="n">offaxis_yoff</span> <span class="o">=</span> <span class="o">-</span><span class="n">head</span><span class="p">[</span><span class="s1">&#39;S</span><span class="si">{}</span><span class="s1">OFFAY&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">primary_source_id</span><span class="p">)]</span><span class="o">/</span><span class="n">pixel_scale</span>
						<span class="n">offaxis_target_center</span> <span class="o">=</span> <span class="p">[</span><span class="n">raw_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">offaxis_xoff</span><span class="p">,</span> <span class="n">raw_centers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">offaxis_yoff</span><span class="p">]</span>

						<span class="c1"># Fit a 2D Gaussian to our offaxis source. </span>
						<span class="n">offaxis_image_smooth</span> <span class="o">=</span> <span class="n">pyklip</span><span class="o">.</span><span class="n">klip</span><span class="o">.</span><span class="n">nan_gaussian_filter</span><span class="p">(</span><span class="n">offaxis_image</span><span class="p">,</span> <span class="n">lambda_d_pixel</span><span class="o">/</span><span class="mf">2.355</span><span class="p">)</span>
						<span class="n">offaxis_bestfit</span> <span class="o">=</span> <span class="n">fakes</span><span class="o">.</span><span class="n">gaussfit2d</span><span class="p">(</span><span class="n">offaxis_image_smooth</span><span class="p">,</span> <span class="n">offaxis_target_center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offaxis_target_center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">searchrad</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">guessfwhm</span><span class="o">=</span><span class="n">lambda_d_pixel</span><span class="p">,</span> <span class="n">guesspeak</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">offaxis_image_smooth</span><span class="p">),</span> <span class="n">refinefit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

						<span class="c1"># Identify the peak flux and centroid of the Gaussian fit</span>
						<span class="n">offaxis_peak_flux</span> <span class="o">=</span> <span class="n">offaxis_bestfit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
						<span class="n">offaxis_psf_xcen</span><span class="p">,</span> <span class="n">offaxis_psf_ycen</span> <span class="o">=</span> <span class="n">offaxis_bestfit</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

						<span class="c1"># Extract a 20x20 pixel PSF stamp image using the x and y centroid. </span>
						<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mf">20.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mf">20.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">#Choice of 20x20 pixels as it encapsulates the bulk of the PSF</span>
						<span class="n">x</span> <span class="o">+=</span> <span class="n">offaxis_psf_xcen</span>
						<span class="n">y</span> <span class="o">+=</span> <span class="n">offaxis_psf_ycen</span>
						<span class="n">offaxis_psf_stamp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">offaxis_image</span><span class="p">,</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
	
	<span class="c1">##### Return a dictionary of the extracted images, their pas, centers, filenames, and some offaxis PSF information. </span>
	<span class="n">extracted</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;images&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="s1">&#39;pas&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pas</span><span class="p">),</span> <span class="s1">&#39;centers&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">),</span> <span class="s1">&#39;filenames&#39;</span><span class="p">:</span><span class="n">filenames</span><span class="p">,</span> <span class="s1">&#39;offaxis_psf_stamp&#39;</span><span class="p">:</span><span class="n">offaxis_psf_stamp</span><span class="p">,</span> <span class="s1">&#39;offaxis_peak_flux&#39;</span><span class="p">:</span><span class="n">offaxis_peak_flux</span><span class="p">}</span>

	<span class="k">return</span> <span class="n">extracted</span></div>
 
<div class="viewcode-block" id="process_simulations"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.process_simulations">[docs]</a><span class="k">def</span> <span class="nf">process_simulations</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">target_obs</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">primary_sources</span><span class="p">,</span> <span class="n">references</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference_obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_rolls</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">reference_rolls</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">subtraction</span><span class="o">=</span><span class="s1">&#39;ADI&#39;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function to process a set of desired simulated images from PanCAKE and convert them into pyKLIP datasets to enable easier stellar PSF subtraction</span>
<span class="sd">	and contrast curve estimation. </span>

<span class="sd">	Parameters</span>
<span class="sd">		pancake_results : HDUList</span>
<span class="sd">			Simulated results as returned by pancake.sequence.Sequence().run()</span>
<span class="sd">		target : string</span>
<span class="sd">			The provided string name for the target scene in the observation sequence</span>
<span class="sd">		target_obs : list of stings</span>
<span class="sd">			List of target observation strings that correspond to extension names in the pancake_results HDUList</span>
<span class="sd">		filt : string</span>
<span class="sd">			JWST filter string</span>
<span class="sd">		mask : string</span>
<span class="sd">			JWST coronagraphic mask string</span>
<span class="sd">		primary_sources : list of strings</span>
<span class="sd">			List of the primary source(s) as obtained by identify_primary_sources</span>
<span class="sd">		references : list of strings</span>
<span class="sd">			The provided string name(s) for the reference scene(s) in the observations sequence, if any.</span>
<span class="sd">		reference_obs : list of strings</span>
<span class="sd">			List of target observation strings that correspond to extension names in the pancake_results HDUList, if any. </span>
<span class="sd">		target_rolls : list of ints / floats</span>
<span class="sd">			Which target PA roll images to use. Alternatively, &#39;default&#39; to use all of them for ADI modes, or roll=0 for RDI. </span>
<span class="sd">		reference_rolls : list of ints / floats</span>
<span class="sd">			Which reference PA roll images to use. Alternatively, &#39;default&#39; to use all of them for ADI modes, or roll=0 for RDI. </span>
<span class="sd">		subtraction : str</span>
<span class="sd">			pyKLIP compatible subtraction string, available options are &#39;ADI&#39;, &#39;RDI&#39;, or &#39;ADI+RDI&#39;</span>
<span class="sd">	Returns</span>
<span class="sd">		processed_output : dict</span>
<span class="sd">			Dictionary output containing pyKLIP datasets for the target and PSF library (if necessary), in addition</span>
<span class="sd">			to some information on the offaxis simulation for normalisation / planet injection purposes. </span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1">###### Get all of the observations names for this simulation</span>
	<span class="n">obs_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">pancake_results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;EXTNAME&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">))]</span>

	<span class="c1">##### Get the names for the target observations, and if necessary, get the reference observations too</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">target_obs</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find specified target/filter/mask observation &#39;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&#39; within simulated results. Possible observations include: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">obs_names</span><span class="p">)))</span>
	<span class="k">if</span> <span class="n">references</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">reference_obs</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">obs_names</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ref</span> <span class="ow">in</span> <span class="n">j</span> <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">references</span><span class="p">)</span> <span class="ow">and</span> <span class="n">filt</span> <span class="ow">in</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">j</span><span class="p">]</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">reference_obs</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find any reference/filter/mask observations of &#39;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&#39; within simulated results. Possible observations include: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;/</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&#39;, &#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">references</span><span class="p">),</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">obs_names</span><span class="p">)))</span>

	<span class="c1">##### Identify roll angles for the target and extract the data</span>
	<span class="n">targ_available_rolls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="n">pancake_results</span><span class="p">[</span><span class="n">tob</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;ROLLANG&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">tob</span> <span class="ow">in</span> <span class="n">target_obs</span><span class="p">]))</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_rolls</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span> <span class="ow">and</span> <span class="s1">&#39;ADI&#39;</span> <span class="ow">in</span> <span class="n">subtraction</span><span class="p">)</span> <span class="ow">or</span> <span class="n">target_rolls</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
		<span class="c1"># Default for the ADI scenario is to use all available rolls</span>
		<span class="n">target_rolls</span> <span class="o">=</span> <span class="n">targ_available_rolls</span>
	<span class="k">elif</span> <span class="n">target_rolls</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span> <span class="ow">and</span> <span class="s1">&#39;ADI&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subtraction</span><span class="p">:</span>
		<span class="c1"># Default for a non-ADI scenario is to use just the roll closest to 0 degrees</span>
		<span class="n">target_rolls</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">targ_available_rolls</span><span class="p">])]</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">targ_available_rolls</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: No ADI requested, using the Roll=</span><span class="si">{}</span><span class="s1"> simulation(s) for </span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_rolls</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="c1"># User has specifically provide the rolls to use, check they exist. </span>
		<span class="k">for</span> <span class="n">roll</span> <span class="ow">in</span> <span class="n">target_rolls</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">roll</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">targ_available_rolls</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find any target observations at roll angle &#39;</span><span class="si">{}</span><span class="s2">&#39; within simulated results. Possible roll angles include: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">targ_available_rolls</span><span class="p">])))</span>

	<span class="c1">##### Need to access the saved simulation files and extract the necessary target data. </span>
	<span class="n">target_extracted</span> <span class="o">=</span> <span class="n">extract_simulated_images</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">,</span> <span class="n">target_obs</span><span class="p">,</span> <span class="n">primary_sources</span><span class="p">,</span> <span class="n">target_rolls</span><span class="p">,</span> <span class="n">extract_offaxis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>
	
	<span class="c1">##### If we are doing RDI at any point, also need to select the RDI rolls and extract the reference images. </span>
	<span class="k">if</span> <span class="s1">&#39;RDI&#39;</span> <span class="ow">in</span> <span class="n">subtraction</span><span class="p">:</span>
		<span class="n">all_ref_available_rolls</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="c1"># Predefine an error message</span>
		<span class="n">roll_err_mess</span> <span class="o">=</span> <span class="s2">&quot;Unable to find any reference observations at roll angle &#39;</span><span class="si">{}</span><span class="s2">&#39; for Scene &#39;</span><span class="si">{}</span><span class="s2">&#39; within simulated results. Possible roll angles include: </span><span class="si">{}</span><span class="s2">&quot;</span>
		<span class="c1"># Loop over input reference scenes </span>
		<span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
			<span class="n">ref_available_rolls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="n">pancake_results</span><span class="p">[</span><span class="n">rob</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;ROLLANG&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">rob</span> <span class="ow">in</span> <span class="n">reference_obs</span> <span class="k">if</span> <span class="s1">&#39;:&#39;</span><span class="o">+</span><span class="n">reference</span><span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="ow">in</span> <span class="n">rob</span><span class="p">]))</span>
			<span class="k">if</span> <span class="n">reference_rolls</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]:</span>
				<span class="c1">#We will use all the available rolls</span>
				<span class="n">all_ref_available_rolls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_available_rolls</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_rolls</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
				<span class="n">roll</span> <span class="o">=</span> <span class="n">reference_rolls</span>
				<span class="c1">#There is only a single roll value provided, use if possible. </span>
				<span class="k">if</span> <span class="n">roll</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ref_available_rolls</span><span class="p">:</span> 
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">roll_err_mess</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ref_available_rolls</span><span class="p">])))</span>
				<span class="n">all_ref_available_rolls</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">roll</span><span class="p">])</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_rolls</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
				<span class="c1">#We have a list of rolls</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_rolls</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
					<span class="c1">#Only one set of values, not nested lists, use for each reference if possible.</span>
					<span class="k">for</span> <span class="n">roll</span> <span class="ow">in</span> <span class="n">reference_rolls</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">roll</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ref_available_rolls</span><span class="p">:</span> 
							<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">roll_err_mess</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ref_available_rolls</span><span class="p">])))</span>
					<span class="n">all_ref_available_rolls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reference_rolls</span><span class="p">)</span>
				<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_rolls</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">references</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_rolls</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
					<span class="c1"># We have a list of lists for each individual reference, use only the index corresponding to the individual reference. </span>
					<span class="n">rolls</span> <span class="o">=</span> <span class="n">reference_rolls</span><span class="p">[</span><span class="n">references</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">reference</span><span class="p">)]</span>
					<span class="k">for</span> <span class="n">roll</span> <span class="ow">in</span> <span class="n">rolls</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">roll</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ref_available_rolls</span><span class="p">:</span> 
							<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">roll_err_mess</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ref_available_rolls</span><span class="p">])))</span>
					<span class="n">all_ref_available_rolls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rolls</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid format of reference rolls provided. Reference rolls must be provided either as an integer/float, a list of integer/floats, or a list of lists of integer/floats of equal length to the provided references.&quot;</span><span class="p">)</span>
	
		<span class="c1">##### Now, access the saved simulation files and extract the necessary reference data. </span>
		<span class="n">ref_extracted</span> <span class="o">=</span> <span class="n">extract_simulated_images</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">,</span> <span class="n">reference_obs</span><span class="p">,</span> <span class="n">primary_sources</span><span class="p">,</span> <span class="n">all_ref_available_rolls</span><span class="p">,</span> <span class="n">references</span><span class="o">=</span><span class="n">references</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="o">=</span><span class="s1">&#39;reference&#39;</span><span class="p">)</span>

	<span class="c1">##### Determine the 1 lambda / D inner working angle for this filter, and outer working angle based on image size</span>
	<span class="n">pixel_scale</span> <span class="o">=</span> <span class="n">pancake_results</span><span class="p">[</span><span class="n">target_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;PIXSCALE&#39;</span><span class="p">]</span>
	<span class="n">wavelength</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">d+&#39;</span><span class="p">,</span> <span class="n">filt</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1e8</span>
	<span class="n">lambda_d_arcsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">wavelength</span> <span class="o">/</span> <span class="mf">6.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3600</span>
	<span class="n">lambda_d_pixel</span> <span class="o">=</span> <span class="n">lambda_d_arcsec</span> <span class="o">/</span> <span class="n">pixel_scale</span> 
	
	<span class="n">inner_working_angle</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">#.5*lambda_d_pixel</span>
	<span class="n">outer_working_angle</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">target_extracted</span><span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  <span class="c1">#Go right to the corners</span>


	<span class="c1">##### Create the KLIP target dataset</span>
	<span class="n">target_dataset</span> <span class="o">=</span> <span class="n">Instrument</span><span class="o">.</span><span class="n">GenericData</span><span class="p">(</span><span class="n">target_extracted</span><span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">],</span> <span class="n">target_extracted</span><span class="p">[</span><span class="s1">&#39;centers&#39;</span><span class="p">],</span> <span class="n">IWA</span><span class="o">=</span><span class="n">inner_working_angle</span><span class="p">,</span> <span class="n">parangs</span><span class="o">=</span><span class="n">target_extracted</span><span class="p">[</span><span class="s1">&#39;pas&#39;</span><span class="p">],</span> <span class="n">filenames</span><span class="o">=</span><span class="n">target_extracted</span><span class="p">[</span><span class="s1">&#39;filenames&#39;</span><span class="p">])</span>
	<span class="n">target_dataset</span><span class="o">.</span><span class="n">OWA</span> <span class="o">=</span> <span class="n">outer_working_angle</span>

	<span class="c1">##### Create the KLIP PSF library if necessary</span>
	<span class="k">if</span> <span class="s1">&#39;RDI&#39;</span> <span class="ow">in</span> <span class="n">subtraction</span><span class="p">:</span>
		<span class="n">psflib_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_extracted</span><span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">],</span> <span class="n">target_extracted</span><span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">psflib_filenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_extracted</span><span class="p">[</span><span class="s1">&#39;filenames&#39;</span><span class="p">],</span> <span class="n">target_extracted</span><span class="p">[</span><span class="s1">&#39;filenames&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">psflib_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_extracted</span><span class="p">[</span><span class="s1">&#39;centers&#39;</span><span class="p">],</span> <span class="n">target_extracted</span><span class="p">[</span><span class="s1">&#39;centers&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

		<span class="n">image_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">psflib_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
		<span class="c1">#Need to align the images so that they have the same centers. </span>
		<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">psflib_data</span><span class="p">):</span>
			<span class="n">recentered_image</span> <span class="o">=</span> <span class="n">pyklip</span><span class="o">.</span><span class="n">klip</span><span class="o">.</span><span class="n">align_and_scale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">new_center</span><span class="o">=</span><span class="n">image_center</span><span class="p">,</span> <span class="n">old_center</span><span class="o">=</span><span class="n">psflib_centers</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="n">psflib_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">recentered_image</span>

		<span class="n">psflib</span> <span class="o">=</span> <span class="n">rdi</span><span class="o">.</span><span class="n">PSFLibrary</span><span class="p">(</span><span class="n">psflib_data</span><span class="p">,</span> <span class="n">image_center</span><span class="p">,</span> <span class="n">psflib_filenames</span><span class="p">,</span> <span class="n">compute_correlation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="c1"># Preparing of the PSF library can raise a future warning, ignore it to keep terminal clean. </span>
		<span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
			<span class="n">psflib</span><span class="o">.</span><span class="n">prepare_library</span><span class="p">(</span><span class="n">target_dataset</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="c1"># Return PSF library as NoneType if we aren&#39;t using a subtraction with RDI</span>
		<span class="n">psflib</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="c1">##### Save the everything to a dictionary for easy access</span>
	<span class="n">processed_output</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">processed_output</span><span class="p">[</span><span class="s1">&#39;target_dataset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_dataset</span>
	<span class="n">processed_output</span><span class="p">[</span><span class="s1">&#39;psflib&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">psflib</span>
	<span class="n">processed_output</span><span class="p">[</span><span class="s1">&#39;offaxis_psf_stamp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_extracted</span><span class="p">[</span><span class="s1">&#39;offaxis_psf_stamp&#39;</span><span class="p">]</span>
	<span class="n">processed_output</span><span class="p">[</span><span class="s1">&#39;offaxis_peak_flux&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_extracted</span><span class="p">[</span><span class="s1">&#39;offaxis_peak_flux&#39;</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">processed_output</span></div>

<div class="viewcode-block" id="mask_companions"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.mask_companions">[docs]</a><span class="k">def</span> <span class="nf">mask_companions</span><span class="p">(</span><span class="n">image_array</span><span class="p">,</span> <span class="n">companion_xy</span><span class="p">,</span> <span class="n">mask_radius</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Function apply NaN masks to a number of images at the location of known companion objects. </span>

<span class="sd">	Parameters</span>
<span class="sd">		image_array : 3D ndarray</span>
<span class="sd">			Numpy array of input images</span>
<span class="sd">		companion_xy : iterator of tuples</span>
<span class="sd">			zip() tuples, with each containing the companion x and y *pixel* locations.</span>
<span class="sd">		mask_radius : float</span>
<span class="sd">			The desired mask radius in pixels. </span>
<span class="sd">	Returns</span>
<span class="sd">		masked_images : 3D ndarray</span>
<span class="sd">			Numpy array of output, companion masked images. </span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="c1"># Create an array to allocate the output images to. 	</span>
	<span class="n">masked_images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">image_array</span><span class="p">)</span>
	<span class="c1"># Loop over images </span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">image_array</span><span class="p">):</span>
		<span class="c1"># Create an index array </span>
		<span class="n">ydat</span><span class="p">,</span> <span class="n">xdat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
		<span class="c1"># Loop over companions, masking all pixels within a radius of the PSF FWHM</span>
		<span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">companion_xy</span><span class="p">:</span>
			<span class="n">distance_from_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xdat</span><span class="o">-</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ydat</span><span class="o">-</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
			<span class="n">comp_nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distance_from_center</span> <span class="o">&lt;=</span> <span class="n">mask_radius</span><span class="p">)</span>
			<span class="n">im</span><span class="p">[</span><span class="n">comp_nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">masked_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span>

	<span class="k">return</span> <span class="n">masked_images</span></div>


<div class="viewcode-block" id="get_companion_mask"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.get_companion_mask">[docs]</a><span class="k">def</span> <span class="nf">get_companion_mask</span><span class="p">(</span><span class="n">companion_xy</span><span class="p">,</span> <span class="n">mask_dataset</span><span class="p">,</span> <span class="n">mask_psflib</span><span class="p">,</span> <span class="n">offaxis_psf_stamp</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;f444w&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;mask335r&#39;</span><span class="p">,</span> <span class="n">annuli</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">subsections</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">numbasis</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">movement</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">subtraction</span><span class="o">=</span><span class="s1">&#39;ADI&#39;</span><span class="p">,</span> <span class="n">outputdir</span><span class="o">=</span><span class="s1">&#39;./RESULTS/&#39;</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Function to create a mask that can be applied to an image in order to &quot;block&quot; any pixels that correspond to the emitted flux of a companion object. </span>
<span class="sd">	In essence, the function uses an offaxis PSF to inject companions into the image, on top of where they already exist, except at a *very* high flux. </span>
<span class="sd">	This image can then be processed via KLIP to identify the pixels in the resultant subtracted image which are most impacted by the presence of </span>
<span class="sd">	the companion object, and assign them to be masked. This offers significant improvements over a simplistic circular mask due to the lobes of the </span>
<span class="sd">	JWST PSF, particularly for the NIRCam filters. Main current drawback is it only masks excess flux from companions, and misses ADI oversubtractions.  </span>

<span class="sd">	&#39;&#39;&#39;</span>
	<span class="c1"># Create our arrays of planets to inject into the input dataset, note the flux is scaled up by a factor of 10^12</span>
	<span class="n">planet_inject</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">offaxis_psf_stamp</span><span class="p">])</span><span class="o">*</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">mask_dataset</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	
	<span class="c1"># Loop over each companion, and inject it into the image. </span>
	<span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">companion_xy</span><span class="p">:</span>
		<span class="n">true_x</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">true_y</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">true_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">true_y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
		<span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">true_y</span><span class="p">,</span> <span class="n">true_x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
		<span class="n">input_theta</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">%</span> <span class="mi">360</span> <span class="c1">#Let&#39;s keep everything positive, just in case</span>
		<span class="n">fakes</span><span class="o">.</span><span class="n">inject_planet</span><span class="p">(</span><span class="n">frames</span><span class="o">=</span><span class="n">mask_dataset</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="n">mask_dataset</span><span class="o">.</span><span class="n">centers</span><span class="p">,</span> <span class="n">inputflux</span><span class="o">=</span><span class="n">planet_inject</span><span class="p">,</span> <span class="n">astr_hdrs</span><span class="o">=</span><span class="n">mask_dataset</span><span class="o">.</span><span class="n">wcs</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">pa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thetas</span><span class="o">=</span><span class="p">[</span><span class="n">input_theta</span><span class="p">],</span> <span class="n">field_dependent_correction</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">transmission_corrected</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span>  <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">))</span>

	<span class="c1"># Perform KLIP on the new images. </span>
	<span class="n">fileprefix</span> <span class="o">=</span> <span class="s2">&quot;FOR_MASKING&quot;</span> <span class="c1">#Adjustable if necessary</span>
	<span class="n">filesuffix</span> <span class="o">=</span> <span class="s2">&quot;-KLmodes-all.fits&quot;</span> <span class="c1">#Don&#39;t adjust</span>
	<span class="n">parallelized</span><span class="o">.</span><span class="n">klip_dataset</span><span class="p">(</span><span class="n">mask_dataset</span><span class="p">,</span> <span class="n">outputdir</span><span class="o">=</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">fileprefix</span><span class="o">=</span><span class="n">fileprefix</span><span class="p">,</span> <span class="n">annuli</span><span class="o">=</span><span class="n">annuli</span><span class="p">,</span> <span class="n">subsections</span><span class="o">=</span><span class="n">subsections</span><span class="p">,</span> <span class="n">numbasis</span><span class="o">=</span><span class="n">numbasis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">subtraction</span><span class="p">,</span> <span class="n">psf_library</span><span class="o">=</span><span class="n">mask_psflib</span><span class="p">,</span> <span class="n">movement</span><span class="o">=</span><span class="n">movement</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

	<span class="c1"># Open the KLIP file and read back in the subtracted image</span>
	<span class="n">injected_file</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">fileprefix</span><span class="p">,</span> <span class="n">filesuffix</span><span class="p">)</span>
	<span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">injected_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdulist</span><span class="p">:</span>
		<span class="n">raw_injected_image</span> <span class="o">=</span> <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">image_x</span><span class="p">,</span> <span class="n">image_y</span>  <span class="o">=</span> <span class="n">raw_injected_image</span><span class="o">.</span><span class="n">shape</span>
		<span class="n">image_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">image_x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">image_x</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">image_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">image_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">image_y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">image_y</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">image_x</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
		<span class="n">injected_image_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;PSFCENTX&quot;</span><span class="p">],</span> <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;PSFCENTY&quot;</span><span class="p">]]</span>
		<span class="n">injected_image</span> <span class="o">=</span> <span class="n">raw_injected_image</span><span class="c1">#transmission_corrected(raw_injected_image, image_dx, image_dy, filt, mask, mode=&#39;divide&#39;) #Correct for coronagraph transmission again</span>

	<span class="c1"># Assign a mask for pixels above a certain flux threshold. 5e-2 times the max seems to do a good job for all filters, fine tuning may</span>
	<span class="c1"># improve things slightly, but likely not for all filters. </span>
	<span class="n">comp_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">injected_image</span> <span class="o">&gt;</span> <span class="mf">5e-2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">injected_image</span><span class="p">))</span>

	<span class="k">return</span> <span class="n">comp_mask</span></div>


<div class="viewcode-block" id="meas_contrast_basic"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.meas_contrast_basic">[docs]</a><span class="k">def</span> <span class="nf">meas_contrast_basic</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">iwa</span><span class="p">,</span> <span class="n">owa</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_pass_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Duplicate of the meas_contrast funciton within pyKLIP, except calculating a </span>
<span class="sd">	standard 5 sigma limit instead of small sample statistics corrections. </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">starx</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">stary</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">starx</span><span class="p">,</span> <span class="n">stary</span> <span class="o">=</span> <span class="n">center</span>

    <span class="c1"># figure out how finely to sample the radial profile</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="n">numseps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">owa</span><span class="o">-</span><span class="n">iwa</span><span class="p">)</span><span class="o">/</span><span class="n">dr</span><span class="p">)</span>
    <span class="c1"># don&#39;t want to start right at the edge of the occulting mask</span>
    <span class="c1"># but also want to well sample the contrast curve so go at twice the resolution</span>
    <span class="n">seps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numseps</span><span class="p">)</span> <span class="o">*</span> <span class="n">dr</span> <span class="o">+</span> <span class="n">iwa</span> <span class="o">+</span> <span class="n">resolution</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="n">dsep</span> <span class="o">=</span> <span class="n">resolution</span>
    <span class="c1"># find equivalent Gaussian PSF for this resolution</span>


    <span class="c1"># run a low pass filter on the data, check if input is boolean or a number</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">low_pass_filter</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="c1"># manually passed in low pass filter size</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">low_pass_filter</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="n">pyklip</span><span class="o">.</span><span class="n">klip</span><span class="o">.</span><span class="n">nan_gaussian_filter</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">low_pass_filter</span><span class="p">:</span>
        <span class="c1"># set low pass filter size to be same as resolution element</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">dsep</span> <span class="o">/</span> <span class="mf">2.355</span>  <span class="c1"># assume resolution element size corresponds to FWHM</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="n">pyklip</span><span class="o">.</span><span class="n">klip</span><span class="o">.</span> <span class="n">nan_gaussian_filter</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># no filtering</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="n">dat</span>

    <span class="n">contrast</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># create a coordinate grid</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">starx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">stary</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">stary</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">starx</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">for</span> <span class="n">sep</span> <span class="ow">in</span> <span class="n">seps</span><span class="p">:</span>
        <span class="c1"># calculate noise in an annulus with width of the resolution element</span>
        <span class="n">annulus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">sep</span> <span class="o">+</span> <span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">sep</span> <span class="o">-</span> <span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">noise_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">filtered</span><span class="p">[</span><span class="n">annulus</span><span class="p">])</span>
        <span class="n">noise_std</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">filtered</span><span class="p">[</span><span class="n">annulus</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">seps</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">noise_std</span><span class="p">)</span></div>

<div class="viewcode-block" id="compute_contrast"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.compute_contrast">[docs]</a><span class="k">def</span> <span class="nf">compute_contrast</span><span class="p">(</span><span class="n">subtracted_hdu_file</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">offaxis_psf_stamp</span><span class="p">,</span> <span class="n">offaxis_flux</span><span class="p">,</span> <span class="n">raw_input_dataset</span><span class="p">,</span> <span class="n">raw_input_psflib</span><span class="p">,</span> <span class="n">primary_vegamag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pixel_scale</span><span class="o">=</span><span class="mf">0.063</span><span class="p">,</span> <span class="n">annuli</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">subsections</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">numbasis</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">movement</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">subtraction</span><span class="o">=</span><span class="s1">&#39;ADI&#39;</span><span class="p">,</span> <span class="n">companion_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">outputdir</span><span class="o">=</span><span class="s1">&#39;./RESULTS/&#39;</span><span class="p">,</span> <span class="n">plot_klip_throughput</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function to compute contrast curves from a pyKLIP subtracted image file. Contrast curves will be corrected for both the coronagraphic and KLIP throughput, </span>
<span class="sd">	in addition to being converted to relative, and absolute magnitude sensitivity limits. </span>

<span class="sd">	Parameters</span>
<span class="sd">		subtracted_hdu_file : str</span>
<span class="sd">			Filename for a subtracted image file as produced by pyklip.parallelized.klip_dataset()</span>
<span class="sd">		filt : str</span>
<span class="sd">			JWST filter string</span>
<span class="sd">		mask : str</span>
<span class="sd">			JWST coronagraphic mask string</span>
<span class="sd">		offaxis_psf_stamp : 2D ndarray</span>
<span class="sd">			Stamp image of an offaxis (i.e. not underneath the coronagraph) PSF</span>
<span class="sd">		offaxis_flux : float</span>
<span class="sd">			Peak flux of the offaxis PSF</span>
<span class="sd">		raw_input_dataset : pyKLIP Dataset</span>
<span class="sd">			The input target dataset that was used to generate the subtracted_hdu_file. Used many times over for planet injection. </span>
<span class="sd">		raw_input_psflib : pyKLIP PSFLibrary</span>
<span class="sd">			The input PSF library dataset that was used to generate the subtracted_hdu_file, if any. Used many times over for planet injection. </span>
<span class="sd">		primary_vegamag : float</span>
<span class="sd">			Vega magnitude of the primary source of the target scene in the specified filter.</span>
<span class="sd">		pixel_scale : float</span>
<span class="sd">			Pixel scale for this observation. </span>
<span class="sd">		annuli : int</span>
<span class="sd">			pyKLIP argument - Annuli to use for KLIP. Can be a number, or a list of 2-element tuples (a, b) specifying the pixel </span>
<span class="sd">			boundaries (a &lt;= r &lt; b) for each annulus</span>
<span class="sd">		subsections : int </span>
<span class="sd">			pyKLIP argument - Sections to break each annuli into. Can be a number [integer], or a list of 2-element tuples (a, b) </span>
<span class="sd">			specifying the positon angle boundaries (a &lt;= PA &lt; b) for each section [radians]</span>
<span class="sd">		numbasis : int</span>
<span class="sd">			number of KL basis vectors to use (can be a scalar or list like). Length of b If numbasis is [None] the number of KL modes to be </span>
<span class="sd">			used is automatically picked based on the eigenvalues.</span>
<span class="sd">		movement : int</span>
<span class="sd">			pyKLIP argument - minimum amount of movement (in pixels) of an astrophysical source to consider using that image for a refernece PSF</span>
<span class="sd">		subtraction : str</span>
<span class="sd">			pyKLIP compatible subtraction string, available options are &#39;ADI&#39;, &#39;RDI&#39;, or &#39;ADI+RDI&#39; </span>
<span class="sd">		companion_xy : iterator of tuples</span>
<span class="sd">			zip() tuples, with each containing any companion x and y *pixel* locations.</span>
<span class="sd">		verbose : bool</span>
<span class="sd">			Optional argument to turn on (True) or off (False) printed terminal updates. </span>
<span class="sd">		outputdir : str</span>
<span class="sd">			Directory to save any temporary or results files. </span>
<span class="sd">		plot_klip_throughput : bool</span>
<span class="sd">			Optional argument to plot (True) the calculated KLIP throughput for each image. Primarily for debugging.  </span>
<span class="sd">	Returns </span>
<span class="sd">		all_contrasts : dict</span>
<span class="sd">			Dictionary output of the contrast, relative magnitude sensitivity, absolute magnitude sensitivity and separation. Alternative</span>
<span class="sd">			formats of the separation, the contrast prior to throughput corrections, and the estimated KLIP throughput, are also provided. </span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="c1">##### First thing we need to do is open the file with the subtracted images. </span>
	<span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">subtracted_hdu_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdulist</span><span class="p">:</span>
		<span class="n">subtracted_hdu</span> <span class="o">=</span> <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">raw_image</span> <span class="o">=</span> <span class="n">subtracted_hdu</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">subtracted_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;PSFCENTX&quot;</span><span class="p">],</span> <span class="n">subtracted_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;PSFCENTY&quot;</span><span class="p">]]</span>

	<span class="c1">##### Get initial properties based on filter and mask input.	</span>
	<span class="n">wavelength</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">d+&#39;</span><span class="p">,</span> <span class="n">filt</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1e8</span>
	<span class="n">lambda_d_arcsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">wavelength</span> <span class="o">/</span> <span class="mf">6.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3600</span>
	<span class="n">lambda_d_pixel</span> <span class="o">=</span> <span class="n">lambda_d_arcsec</span> <span class="o">/</span> <span class="n">pixel_scale</span> 
	
	<span class="c1"># Set the IWA to 0.5 lambda/D, contrast will be calculated from 1 lambda / D</span>
	<span class="n">inner_working_angle</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">lambda_d_pixel</span> 
	<span class="c1"># For the OWA, get inaccurate measurements close to the edges of the simulated image, so only go 95% of the way. </span>
	<span class="c1"># In reality many more pixels will be available as simulation is a small portion of detector, so this effect is artificial.</span>
	<span class="n">outer_working_angle</span> <span class="o">=</span> <span class="mf">0.95</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">raw_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> 

	<span class="c1">##### Normalise by the coronagraphic throughput</span>
	<span class="n">image_x</span><span class="p">,</span> <span class="n">image_y</span>  <span class="o">=</span> <span class="n">raw_image</span><span class="o">.</span><span class="n">shape</span>
	<span class="n">image_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">image_x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">image_x</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">image_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
	<span class="n">image_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">image_y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">image_y</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">image_x</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
	<span class="n">image</span> <span class="o">=</span> <span class="n">transmission_corrected</span><span class="p">(</span><span class="n">raw_image</span><span class="p">,</span> <span class="n">image_dx</span><span class="p">,</span> <span class="n">image_dy</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;divide&#39;</span><span class="p">)</span>

	<span class="c1">##### If we aren&#39;t using a spherically symmetric coronagraph, we should mask out certain pixels to improve the contrast measurement. </span>
	<span class="k">if</span> <span class="n">mask</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;MASKSWB&#39;</span><span class="p">,</span> <span class="s1">&#39;MASKLWB&#39;</span><span class="p">,</span> <span class="s1">&#39;FQPM1065&#39;</span><span class="p">,</span> <span class="s1">&#39;FQPM1140&#39;</span><span class="p">,</span> <span class="s1">&#39;FQPM1550&#39;</span><span class="p">]:</span>
		<span class="n">mask_throughput</span> <span class="o">=</span> <span class="n">raw_image</span> <span class="o">/</span> <span class="n">image</span>
		<span class="c1"># Identify a level at which pixels should be set to nans, be slightly more aggresive for MIRI</span>
		<span class="k">if</span> <span class="n">mask</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;MASKSWB&#39;</span><span class="p">,</span> <span class="s1">&#39;MASKLWB&#39;</span><span class="p">]:</span> 
			<span class="n">nan_cut</span> <span class="o">=</span> <span class="mf">0.5</span>
		<span class="k">elif</span> <span class="n">mask</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;FQPM1065&#39;</span><span class="p">,</span> <span class="s1">&#39;FQPM1140&#39;</span><span class="p">,</span> <span class="s1">&#39;FQPM1550&#39;</span><span class="p">]:</span> 
			<span class="n">nan_cut</span> <span class="o">=</span> <span class="mf">0.65</span>

		<span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_throughput</span><span class="o">&lt;</span><span class="n">nan_cut</span><span class="p">)</span>
		<span class="n">raw_image</span><span class="p">[</span><span class="n">nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">image</span><span class="p">[</span><span class="n">nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

	<span class="c1">##### Also, if there are companions in the image, these should be masked out. </span>
	<span class="k">if</span> <span class="n">companion_xy</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> 
		<span class="n">comp_mask_dataset</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">raw_input_dataset</span><span class="p">)</span>
		<span class="n">comp_mask_psflib</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">raw_input_psflib</span><span class="p">)</span>
		<span class="n">comp_mask</span> <span class="o">=</span> <span class="n">get_companion_mask</span><span class="p">(</span><span class="n">companion_xy</span><span class="p">,</span> <span class="n">comp_mask_dataset</span><span class="p">,</span> <span class="n">comp_mask_psflib</span><span class="p">,</span> <span class="n">offaxis_psf_stamp</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">annuli</span><span class="o">=</span><span class="n">annuli</span><span class="p">,</span> <span class="n">subsections</span><span class="o">=</span><span class="n">subsections</span><span class="p">,</span> <span class="n">numbasis</span><span class="o">=</span><span class="n">numbasis</span><span class="p">,</span> <span class="n">subtraction</span><span class="o">=</span><span class="n">subtraction</span><span class="p">,</span> <span class="n">movement</span><span class="o">=</span><span class="n">movement</span><span class="p">,</span> <span class="n">outputdir</span><span class="o">=</span><span class="n">outputdir</span><span class="p">)</span>
		<span class="n">raw_image</span><span class="p">[</span><span class="n">comp_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">image</span><span class="p">[</span><span class="n">comp_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

	<span class="c1">##### Divide by the peak of the offaxis flux to convert the images into contrast</span>
	<span class="n">raw_image</span> <span class="o">/=</span> <span class="n">offaxis_flux</span>
	<span class="n">image</span> <span class="o">/=</span> <span class="n">offaxis_flux</span>

	<span class="c1">##### Grab a contrast measurement before and after the coronagraphic throughput correction</span>
	<span class="n">uncorr_contrast_seps</span><span class="p">,</span> <span class="n">uncorr_contrast</span> <span class="o">=</span> <span class="n">pyklip</span><span class="o">.</span><span class="n">klip</span><span class="o">.</span><span class="n">meas_contrast</span><span class="p">(</span><span class="n">dat</span><span class="o">=</span><span class="n">raw_image</span><span class="p">,</span> <span class="n">iwa</span><span class="o">=</span><span class="n">inner_working_angle</span><span class="p">,</span> <span class="n">owa</span><span class="o">=</span><span class="n">outer_working_angle</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">lambda_d_pixel</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">low_pass_filter</span><span class="o">=</span><span class="n">lambda_d_pixel</span><span class="o">/</span><span class="mf">2.355</span><span class="p">)</span>
	<span class="n">contrast_seps</span><span class="p">,</span> <span class="n">contrast</span> <span class="o">=</span> <span class="n">pyklip</span><span class="o">.</span><span class="n">klip</span><span class="o">.</span><span class="n">meas_contrast</span><span class="p">(</span><span class="n">dat</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">iwa</span><span class="o">=</span><span class="n">inner_working_angle</span><span class="p">,</span> <span class="n">owa</span><span class="o">=</span><span class="n">outer_working_angle</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">lambda_d_pixel</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">low_pass_filter</span><span class="o">=</span><span class="n">lambda_d_pixel</span><span class="o">/</span><span class="mf">2.355</span><span class="p">)</span>

	<span class="n">uncorr_contrast_seps_raw5sig</span><span class="p">,</span> <span class="n">uncorr_contrast_raw5sig</span> <span class="o">=</span> <span class="n">meas_contrast_basic</span><span class="p">(</span><span class="n">dat</span><span class="o">=</span><span class="n">raw_image</span><span class="p">,</span> <span class="n">iwa</span><span class="o">=</span><span class="n">inner_working_angle</span><span class="p">,</span> <span class="n">owa</span><span class="o">=</span><span class="n">outer_working_angle</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">low_pass_filter</span><span class="o">=</span><span class="n">lambda_d_pixel</span><span class="o">/</span><span class="mf">2.355</span><span class="p">)</span>
	<span class="n">contrast_seps_raw5sig</span><span class="p">,</span> <span class="n">contrast_raw5sig</span> <span class="o">=</span> <span class="n">meas_contrast_basic</span><span class="p">(</span><span class="n">dat</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">iwa</span><span class="o">=</span><span class="n">inner_working_angle</span><span class="p">,</span> <span class="n">owa</span><span class="o">=</span><span class="n">outer_working_angle</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">low_pass_filter</span><span class="o">=</span><span class="n">lambda_d_pixel</span><span class="o">/</span><span class="mf">2.355</span><span class="p">)</span>

	<span class="c1">##### At this stage contrast is usable, but has not been calibrated for the KLIP throughput. </span>
	<span class="c1">##### Need to inject planets into the raw_image and see how well they are recovered </span>
	<span class="c1">#Define injection values </span>
	<span class="n">min_sep</span> <span class="o">=</span> <span class="n">inner_working_angle</span> <span class="c1"># Minimum injection separation</span>
	<span class="n">max_sep</span> <span class="o">=</span> <span class="n">outer_working_angle</span> <span class="c1"># Maximum injection separation</span>
	
	<span class="n">nplanets</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1">#Just inject 1 planet at a time, but can do multiple at once. </span>
	<span class="n">inter_planet_sep</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Radial separation in pixels between each planet injection.</span>
	<span class="n">start_pas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="o">*</span><span class="p">(</span><span class="n">nplanets</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">nplanets</span><span class="p">,</span> <span class="n">nplanets</span><span class="p">)</span> <span class="c1">#Starting PA&#39;s for the injected planets. </span>
	<span class="n">num_pas</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># Number of different PA&#39;s to look at for each separation. Should avoid values of 1,2,4 for MIRI as they will lie behind the 4QPM edges. </span>

	<span class="c1"># Maximum separation of first iteration and number of loops needed. </span>
	<span class="n">max_sep_1</span> <span class="o">=</span> <span class="n">min_sep</span> <span class="o">+</span> <span class="p">(</span><span class="n">inter_planet_sep</span> <span class="o">*</span> <span class="p">(</span><span class="n">nplanets</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
	<span class="n">n_sep_loops</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((((</span><span class="n">max_sep</span> <span class="o">-</span> <span class="n">min_sep</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">inter_planet_sep</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">nplanets</span><span class="p">)</span>

	<span class="c1">#Offaxis psf stamp to use for injection</span>
	<span class="n">psf_stamp_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">offaxis_psf_stamp</span><span class="p">])</span> 

	<span class="n">retrieved_fluxes_all</span><span class="p">,</span> <span class="n">planet_pas_all</span><span class="p">,</span> <span class="n">planet_seps_all</span><span class="p">,</span> <span class="n">input_contrasts_all</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
	<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>	<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--&gt; Determining KLIP Throughput&#39;</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sep_loops</span><span class="p">):</span>
		<span class="c1"># Create array of separations and contrasts to be injected at, spaced by desired distance b/t planets</span>
		<span class="n">planet_seps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_sep</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">nplanets</span><span class="o">*</span><span class="n">inter_planet_sep</span><span class="p">),</span> <span class="n">max_sep_1</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">nplanets</span><span class="o">*</span><span class="n">inter_planet_sep</span><span class="p">),</span> <span class="n">inter_planet_sep</span><span class="p">)</span>

		<span class="c1"># Gather contrasts at the separation of the injected planet for the *uncorrected* images, i.e coronagraph throughput is still there. </span>
		<span class="n">input_contrasts</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">planet_seps</span><span class="p">,</span> <span class="n">contrast_seps</span><span class="p">,</span> <span class="n">uncorr_contrast</span><span class="p">))</span><span class="o">*</span><span class="mi">4000</span>

		<span class="c1"># Loop over however many PA&#39;s were requested. </span>
		<span class="k">for</span> <span class="n">num_pa</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pas</span><span class="p">):</span>
			<span class="c1"># Copy our dataset, otherwise we&#39;ll keep injecting planets into the same image. </span>
			<span class="n">input_dataset</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">raw_input_dataset</span><span class="p">)</span>
			<span class="n">input_psflib</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">raw_input_psflib</span><span class="p">)</span>

			<span class="c1"># Rotate the planets between each iteration, equally spaced based on num_pas - plus a slight deviation to break symmetries. </span>
			<span class="n">planet_pas</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">360</span><span class="o">*</span><span class="n">num_pa</span><span class="p">)</span><span class="o">/</span><span class="n">num_pas</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">start_pas</span><span class="p">]</span>
			
			<span class="c1"># Loop over all of the planets to be injected. </span>
			<span class="n">injected</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Record whether planets were injected or not</span>
			<span class="k">for</span> <span class="n">input_contrast</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">pa</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_contrasts</span><span class="p">,</span> <span class="n">planet_seps</span><span class="p">,</span> <span class="n">planet_pas</span><span class="p">):</span>
				<span class="c1"># Let&#39;s do some checks to make sure we want to inject a planet here</span>
				<span class="n">perform_injection</span> <span class="o">=</span> <span class="kc">True</span>

				<span class="c1"># Make sure we don&#39;t inject planets on top of, or close to, existing planets</span>
				<span class="k">if</span> <span class="n">companion_xy</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
					<span class="c1">#Get pixel position, make sure to minus the x position as we are going counterclockwise</span>
					<span class="n">check_pos_x</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">sep</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pa</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">))</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
					<span class="n">check_pos_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">sep</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">pa</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">))</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
					<span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">companion_xy</span><span class="p">:</span>
						<span class="n">dist_planet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">check_pos_x</span> <span class="o">-</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">check_pos_y</span> <span class="o">-</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
						<span class="c1"># Don&#39;t inject planets within 2 lambda/D of an existing companion. </span>
						<span class="k">if</span> <span class="n">dist_planet</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">lambda_d_pixel</span><span class="p">:</span> 
							<span class="n">perform_injection</span> <span class="o">=</span> <span class="kc">False</span>

				<span class="k">if</span> <span class="n">perform_injection</span><span class="p">:</span>
					<span class="n">base_planet_flux</span> <span class="o">=</span> <span class="n">psf_stamp_input</span> <span class="o">*</span> <span class="n">input_contrast</span>
					<span class="n">planet_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">base_planet_flux</span><span class="p">,</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#Need to pass as many planet PSF stamps as there are target images.  </span>
					<span class="c1">### Tidy later, but essentially if specifying the input thetas, you have to do so for every input ADI frame, not just a single angle. </span>
					<span class="c1">### Also, for some reason, the array needs to be flipped relative to the input_dataset.PAs to line things up correctly. </span>
					<span class="n">input_thetas</span> <span class="o">=</span> <span class="p">((</span><span class="mi">270</span> <span class="o">-</span> <span class="n">pa</span> <span class="o">-</span> <span class="n">input_dataset</span><span class="o">.</span><span class="n">PAs</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span>
					<span class="n">fakes</span><span class="o">.</span><span class="n">inject_planet</span><span class="p">(</span><span class="n">frames</span><span class="o">=</span><span class="n">input_dataset</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="n">input_dataset</span><span class="o">.</span><span class="n">centers</span><span class="p">,</span> <span class="n">inputflux</span><span class="o">=</span><span class="n">planet_flux</span><span class="p">,</span> <span class="n">astr_hdrs</span><span class="o">=</span><span class="n">input_dataset</span><span class="o">.</span><span class="n">wcs</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">pa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thetas</span><span class="o">=</span><span class="n">input_thetas</span><span class="p">,</span> <span class="n">field_dependent_correction</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">transmission_corrected</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span>  <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">))</span>
					<span class="n">injected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="c1"># Just move to the next injection location</span>
					<span class="n">injected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
					<span class="k">continue</span>

			<span class="c1"># Now want to run KLIP on these planet injected images</span>
			<span class="n">fileprefix</span> <span class="o">=</span> <span class="s2">&quot;FAKE_INJECTED_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_pas</span><span class="p">)</span> <span class="c1">#Adjustable if necessary</span>
			<span class="n">filesuffix</span> <span class="o">=</span> <span class="s2">&quot;-KLmodes-all.fits&quot;</span> <span class="c1">#Don&#39;t adjust</span>
			<span class="n">parallelized</span><span class="o">.</span><span class="n">klip_dataset</span><span class="p">(</span><span class="n">input_dataset</span><span class="p">,</span> <span class="n">outputdir</span><span class="o">=</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">fileprefix</span><span class="o">=</span><span class="n">fileprefix</span><span class="p">,</span> <span class="n">annuli</span><span class="o">=</span><span class="n">annuli</span><span class="p">,</span> <span class="n">subsections</span><span class="o">=</span><span class="n">subsections</span><span class="p">,</span> <span class="n">numbasis</span><span class="o">=</span><span class="n">numbasis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">subtraction</span><span class="p">,</span> <span class="n">psf_library</span><span class="o">=</span><span class="n">input_psflib</span><span class="p">,</span> <span class="n">movement</span><span class="o">=</span><span class="n">movement</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
	
			<span class="c1">#Reopen produced file from pyKLIP</span>
			<span class="n">injected_file</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">fileprefix</span><span class="p">,</span> <span class="n">filesuffix</span><span class="p">)</span>
			<span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">injected_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdulist</span><span class="p">:</span>
				<span class="n">raw_injected_image</span> <span class="o">=</span> <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">injected_image_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;PSFCENTX&quot;</span><span class="p">],</span> <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;PSFCENTY&quot;</span><span class="p">]]</span>
				<span class="n">injected_image</span> <span class="o">=</span> <span class="n">transmission_corrected</span><span class="p">(</span><span class="n">raw_injected_image</span><span class="p">,</span> <span class="n">image_dx</span><span class="p">,</span> <span class="n">image_dy</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;divide&#39;</span><span class="p">)</span> <span class="c1">#Correct for coronagraph transmission again</span>

			<span class="c1"># Retrieve the planetary flux and append it to our initial array</span>
			<span class="n">retrieved_planet_fluxes</span><span class="p">,</span> <span class="n">used_contrasts</span><span class="p">,</span> <span class="n">used_seps</span><span class="p">,</span> <span class="n">used_pas</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">input_contrast</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">inj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_contrasts</span><span class="p">,</span> <span class="n">planet_seps</span><span class="p">,</span> <span class="n">planet_pas</span><span class="p">,</span> <span class="n">injected</span><span class="p">):</span>
				<span class="c1"># Planet injection step.</span>
				<span class="k">if</span> <span class="n">inj</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
					<span class="c1"># Before we retrieve the flux, we need to apply a low pass filter (smoothing) to the images, as this is what was done to </span>
					<span class="c1"># obtain the contrast curve. Make sure to use the same value of lambda_d_pixel/2.355. </span>
	
					<span class="n">injected_image</span> <span class="o">=</span> <span class="n">pyklip</span><span class="o">.</span><span class="n">klip</span><span class="o">.</span><span class="n">nan_gaussian_filter</span><span class="p">(</span><span class="n">injected_image</span><span class="p">,</span> <span class="n">lambda_d_pixel</span><span class="o">/</span><span class="mf">2.355</span><span class="p">)</span>
					<span class="n">input_theta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">270</span> <span class="o">-</span> <span class="n">pa</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
					<span class="n">fake_flux</span> <span class="o">=</span> <span class="n">fakes</span><span class="o">.</span><span class="n">retrieve_planet_flux</span><span class="p">(</span><span class="n">frames</span><span class="o">=</span><span class="n">injected_image</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="n">injected_image_centers</span><span class="p">,</span> <span class="n">astr_hdrs</span><span class="o">=</span><span class="n">input_dataset</span><span class="o">.</span><span class="n">output_wcs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">pa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thetas</span><span class="o">=</span><span class="n">input_theta</span><span class="p">,</span> <span class="n">searchrad</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">lambda_d_pixel</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="n">guessfwhm</span><span class="o">=</span><span class="n">lambda_d_pixel</span><span class="p">)</span>

					<span class="n">retrieved_planet_fluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fake_flux</span><span class="p">)</span>
					<span class="n">used_contrasts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_contrast</span><span class="p">)</span>
					<span class="n">used_seps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
					<span class="n">used_pas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span>

			<span class="c1"># Add things to the arrays defined at the start</span>
			<span class="n">retrieved_fluxes_all</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">retrieved_planet_fluxes</span><span class="p">)</span>
			<span class="n">planet_pas_all</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">used_pas</span><span class="p">)</span>
			<span class="n">planet_seps_all</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">used_seps</span><span class="p">)</span>
			<span class="n">input_contrasts_all</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">used_contrasts</span><span class="p">)</span>

			<span class="c1"># Delete the injected planet image, as it will only clutter the directory</span>
			<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">injected_file</span><span class="p">)</span>

	<span class="c1">##### So, now planets have been injected into a variety of images and the flux prior to and after the injection has been measured. </span>
	<span class="c1">##### What we can now do is use this flux ratio to calibrate the contrast curve for the KLIP throughput. </span>

	<span class="c1"># Create a table of all variables</span>
	<span class="n">inject_vars</span> <span class="o">=</span> <span class="n">Table</span><span class="p">([</span><span class="n">retrieved_fluxes_all</span><span class="p">,</span> <span class="n">planet_seps_all</span><span class="p">,</span> <span class="n">input_contrasts_all</span><span class="p">,</span> <span class="n">planet_pas_all</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;flux&quot;</span><span class="p">,</span> <span class="s2">&quot;separation&quot;</span><span class="p">,</span> <span class="s2">&quot;input_contrast&quot;</span><span class="p">,</span> <span class="s2">&quot;pas&quot;</span><span class="p">))</span>
	
	<span class="n">inject_vars</span><span class="p">[</span><span class="s2">&quot;input_flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inject_vars</span><span class="p">[</span><span class="s2">&quot;input_contrast&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">offaxis_flux</span> <span class="c1">#Peak flux from the offaxis PSF </span>
	<span class="n">inject_vars</span><span class="p">[</span><span class="s2">&quot;throughput&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inject_vars</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">inject_vars</span><span class="p">[</span><span class="s2">&quot;input_flux&quot;</span><span class="p">]</span> <span class="c1"># Calculate throughput and add it to the table</span>

	<span class="n">inject_vars_grouped</span> <span class="o">=</span> <span class="n">inject_vars</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="s2">&quot;separation&quot;</span><span class="p">)</span> <span class="c1"># Group by separation</span>
	<span class="n">med_inject_vars</span> <span class="o">=</span> <span class="n">inject_vars_grouped</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">)</span> <span class="c1"># Calculate the median values at each separation</span>

	<span class="c1"># Can&#39;t have a negative throughput, but can arise erroneously very close to the primary source due to speckle noise.</span>
	<span class="c1"># Counteract this by setting all negative throughput values to a very low value of 1e-10</span>
	<span class="n">med_inject_vars</span><span class="p">[</span><span class="s2">&quot;throughput&quot;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">med_inject_vars</span><span class="p">[</span><span class="s1">&#39;throughput&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1e-10</span>

	<span class="c1"># Find the throughput for the separations the contrast curve has been computed at</span>
	<span class="n">throughput_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">contrast_seps</span><span class="p">,</span> <span class="n">med_inject_vars</span><span class="p">[</span><span class="s1">&#39;separation&#39;</span><span class="p">],</span> <span class="n">med_inject_vars</span><span class="p">[</span><span class="s2">&quot;throughput&quot;</span><span class="p">])</span>

	<span class="c1"># Apply median KLIP throughput to the 5 sigma contrast curve which **has** been already corrected for the coronagraph throughput </span>
	<span class="n">klip_corrected_contrast</span> <span class="o">=</span> <span class="n">contrast</span> <span class="o">/</span> <span class="n">throughput_interp</span>

	<span class="c1">##### Convert to relative / absolute magnitudes.</span>
	<span class="n">relmag</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">klip_corrected_contrast</span><span class="p">)</span>
	<span class="n">absmag</span> <span class="o">=</span> <span class="n">relmag</span> <span class="o">+</span> <span class="n">primary_vegamag</span>

	<span class="c1">##### Now make it all again, but for the basic 5 sigma curves with no small separation correction</span>
	<span class="n">throughput_interp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">contrast_seps_raw5sig</span><span class="p">,</span> <span class="n">med_inject_vars</span><span class="p">[</span><span class="s1">&#39;separation&#39;</span><span class="p">],</span> <span class="n">med_inject_vars</span><span class="p">[</span><span class="s1">&#39;throughput&#39;</span><span class="p">])</span>
	<span class="n">klip_corrected_contrast_raw5sig</span> <span class="o">=</span> <span class="n">contrast_raw5sig</span> <span class="o">/</span> <span class="n">throughput_interp2</span>
	<span class="n">relmag_raw5sig</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">klip_corrected_contrast_raw5sig</span><span class="p">)</span>
	<span class="n">absmag_raw5sig</span> <span class="o">=</span> <span class="n">relmag_raw5sig</span> <span class="o">+</span> <span class="n">primary_vegamag</span>

	<span class="c1"># Prepare dictionary to return contrasts, give things more descriptive names for users. </span>
	<span class="n">all_contrasts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;separation&#39;</span><span class="p">:</span><span class="n">contrast_seps</span><span class="p">,</span> <span class="s1">&#39;separation_arcsec&#39;</span><span class="p">:</span><span class="n">contrast_seps</span><span class="o">*</span><span class="n">pixel_scale</span><span class="p">,</span> <span class="s1">&#39;separation_lambdad&#39;</span><span class="p">:</span><span class="n">contrast_seps</span><span class="o">/</span><span class="n">lambda_d_pixel</span><span class="p">,</span> <span class="s1">&#39;contrast_noklipthrput_nocorothrput&#39;</span><span class="p">:</span><span class="n">uncorr_contrast</span><span class="p">,</span> <span class="s1">&#39;contrast_noklipthrput&#39;</span><span class="p">:</span><span class="n">contrast</span><span class="p">,</span> <span class="s1">&#39;contrast&#39;</span><span class="p">:</span><span class="n">klip_corrected_contrast</span><span class="p">,</span> <span class="s1">&#39;klipthrput&#39;</span><span class="p">:</span><span class="n">throughput_interp</span><span class="p">,</span> <span class="s1">&#39;relmag&#39;</span><span class="p">:</span><span class="n">relmag</span><span class="p">,</span> <span class="s1">&#39;absmag&#39;</span><span class="p">:</span><span class="n">absmag</span><span class="p">,</span> <span class="s1">&#39;separation_raw5sig&#39;</span><span class="p">:</span><span class="n">contrast_seps_raw5sig</span><span class="p">,</span> <span class="s1">&#39;separation_arcsec_raw5sig&#39;</span><span class="p">:</span><span class="n">contrast_seps_raw5sig</span><span class="o">*</span><span class="n">pixel_scale</span><span class="p">,</span> <span class="s1">&#39;separation_lambdad_raw5sig&#39;</span><span class="p">:</span><span class="n">contrast_seps_raw5sig</span><span class="o">/</span><span class="n">lambda_d_pixel</span><span class="p">,</span><span class="s1">&#39;contrast_noklipthrput_nocorothrput_raw5sig&#39;</span><span class="p">:</span><span class="n">uncorr_contrast_raw5sig</span><span class="p">,</span> <span class="s1">&#39;contrast_noklipthrput_raw5sig&#39;</span><span class="p">:</span><span class="n">contrast_raw5sig</span><span class="p">,</span> <span class="s1">&#39;contrast_raw5sig&#39;</span><span class="p">:</span><span class="n">klip_corrected_contrast_raw5sig</span><span class="p">,</span> <span class="s1">&#39;relmag_raw5sig&#39;</span><span class="p">:</span><span class="n">relmag_raw5sig</span><span class="p">,</span> <span class="s1">&#39;absmag_raw5sig&#39;</span><span class="p">:</span><span class="n">absmag_raw5sig</span><span class="p">}</span>

	<span class="k">if</span> <span class="n">plot_klip_throughput</span><span class="p">:</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
		<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">med_inject_vars</span><span class="p">[</span><span class="s2">&quot;separation&quot;</span><span class="p">],</span> <span class="n">med_inject_vars</span><span class="p">[</span><span class="s2">&quot;throughput&quot;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#577B51&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Median Throughput&quot;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">inject_vars</span><span class="p">[</span><span class="s2">&quot;separation&quot;</span><span class="p">],</span> <span class="n">inject_vars</span><span class="p">[</span><span class="s2">&quot;throughput&quot;</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#95B2B8&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Throughput&quot;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Planet Separation&quot;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Algorithm Throughput&quot;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower left&quot;</span><span class="p">)</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

	<span class="k">return</span> <span class="n">all_contrasts</span></div>

<div class="viewcode-block" id="get_source_properties"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.get_source_properties">[docs]</a><span class="k">def</span> <span class="nf">get_source_properties</span><span class="p">(</span><span class="n">template_obs</span><span class="p">,</span> <span class="n">primary_source</span><span class="p">):</span>
	<span class="n">header</span> <span class="o">=</span> <span class="n">template_obs</span><span class="o">.</span><span class="n">header</span>
	<span class="n">pixel_scale</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;PIXSCALE&#39;</span><span class="p">]</span>
	<span class="n">num_sources</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;NSOURCES&#39;</span><span class="p">]</span>

	<span class="n">raw_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">template_obs</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

	<span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SOURCE</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sources</span><span class="p">)]</span>
	<span class="n">primary_source_id</span> <span class="o">=</span> <span class="n">sources</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">primary_source</span><span class="p">)</span>

	<span class="c1"># Gather target props</span>
	<span class="n">target_primary_vegamag</span> <span class="o">=</span> <span class="n">template_obs</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;S</span><span class="si">{}</span><span class="s1">VGAMG&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">primary_source_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
	<span class="n">target_xoff</span> <span class="o">=</span> <span class="n">template_obs</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;S</span><span class="si">{}</span><span class="s1">XOFF1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">primary_source_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">/</span> <span class="n">pixel_scale</span>
	<span class="n">target_yoff</span> <span class="o">=</span> <span class="o">-</span><span class="n">template_obs</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;S</span><span class="si">{}</span><span class="s1">YOFF1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">primary_source_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">/</span> <span class="n">pixel_scale</span>

	<span class="k">if</span> <span class="n">num_sources</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
		<span class="c1"># Gather companion props</span>
		<span class="n">comp_xoffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;S</span><span class="si">{}</span><span class="s1">XOFF1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">/</span><span class="n">pixel_scale</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sources</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">primary_source_id</span><span class="p">])</span>
		<span class="n">comp_yoffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;S</span><span class="si">{}</span><span class="s1">YOFF1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">/</span><span class="n">pixel_scale</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sources</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">primary_source_id</span><span class="p">])</span>	
		
		<span class="n">comp_seps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">comp_xoffs</span><span class="o">-</span><span class="n">target_xoff</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">comp_yoffs</span><span class="o">-</span><span class="n">target_yoff</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixel_scale</span>
		<span class="n">comp_xy</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">comp_xoffs</span><span class="o">+</span><span class="n">raw_center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">comp_yoffs</span><span class="o">+</span><span class="n">raw_center</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
		<span class="n">comp_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SOURCE</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sources</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">primary_source_id</span><span class="p">]</span>

		<span class="n">comp_vegamags</span> <span class="o">=</span> <span class="p">[</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;S</span><span class="si">{}</span><span class="s1">VGAMG&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sources</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">primary_source_id</span><span class="p">]</span>
		<span class="n">comp_contrasts</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">comp_vegamags</span><span class="p">)</span> <span class="o">-</span> <span class="n">target_primary_vegamag</span><span class="p">))</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">comp_vegamags</span><span class="p">,</span> <span class="n">comp_seps</span><span class="p">,</span> <span class="n">comp_xy</span><span class="p">,</span> <span class="n">comp_names</span><span class="p">,</span> <span class="n">comp_contrasts</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

	<span class="n">source_props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;target_primary_vegamag&#39;</span><span class="p">:</span><span class="n">target_primary_vegamag</span><span class="p">,</span> <span class="s1">&#39;comp_vegamags&#39;</span><span class="p">:</span><span class="n">comp_vegamags</span><span class="p">,</span> <span class="s1">&#39;comp_seps&#39;</span><span class="p">:</span><span class="n">comp_seps</span><span class="p">,</span> <span class="s1">&#39;comp_xy&#39;</span><span class="p">:</span><span class="n">comp_xy</span><span class="p">,</span> <span class="s1">&#39;comp_names&#39;</span><span class="p">:</span><span class="n">comp_names</span><span class="p">,</span> <span class="s1">&#39;comp_contrasts&#39;</span><span class="p">:</span><span class="n">comp_contrasts</span><span class="p">}</span>

	<span class="k">return</span> <span class="n">source_props</span></div>

<div class="viewcode-block" id="companion_snrs"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.companion_snrs">[docs]</a><span class="k">def</span> <span class="nf">companion_snrs</span><span class="p">(</span><span class="n">subtracted_hdu_file</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">companion_xy</span><span class="p">,</span> <span class="n">mask_radius</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
	<span class="c1"># Read in the file</span>
	<span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">subtracted_hdu_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdulist</span><span class="p">:</span>
		<span class="n">subtracted_hdu</span> <span class="o">=</span> <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">raw_image</span> <span class="o">=</span> <span class="n">subtracted_hdu</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">subtracted_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;PSFCENTX&quot;</span><span class="p">],</span> <span class="n">subtracted_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;PSFCENTY&quot;</span><span class="p">]]</span>

	<span class="c1"># Correct for the coronagraphic throughput</span>
	<span class="n">image_x</span><span class="p">,</span> <span class="n">image_y</span>  <span class="o">=</span> <span class="n">raw_image</span><span class="o">.</span><span class="n">shape</span>
	<span class="n">image_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">image_x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">image_x</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">image_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
	<span class="n">image_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">image_y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">image_y</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">image_x</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
	<span class="n">image</span> <span class="o">=</span> <span class="n">transmission_corrected</span><span class="p">(</span><span class="n">raw_image</span><span class="p">,</span> <span class="n">image_dx</span><span class="p">,</span> <span class="n">image_dy</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;divide&#39;</span><span class="p">)</span>

	<span class="c1"># Construct a grid with the same shape as the image, compute radial distance from image center</span>
	<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
	<span class="n">rad_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

	<span class="c1"># Mask the coronagraphic bar</span>
	<span class="k">if</span> <span class="n">mask</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;MASKSWB&#39;</span><span class="p">,</span> <span class="s1">&#39;MASKLWB&#39;</span><span class="p">,</span> <span class="s1">&#39;FQPM1065&#39;</span><span class="p">,</span> <span class="s1">&#39;FQPM1140&#39;</span><span class="p">,</span> <span class="s1">&#39;FQPM1550&#39;</span><span class="p">]:</span>
		<span class="n">mask_throughput</span> <span class="o">=</span> <span class="n">raw_image</span> <span class="o">/</span> <span class="n">image</span>

		<span class="c1"># Identify a level at which pixels should be set to nans. Be less aggresive than contrast measurement.</span>
		<span class="k">if</span> <span class="n">mask</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;MASKSWB&#39;</span><span class="p">,</span> <span class="s1">&#39;MASKLWB&#39;</span><span class="p">]:</span> 
			<span class="n">nan_cut</span> <span class="o">=</span> <span class="mf">0.5</span>
		<span class="k">elif</span> <span class="n">mask</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;FQPM1065&#39;</span><span class="p">,</span> <span class="s1">&#39;FQPM1140&#39;</span><span class="p">,</span> <span class="s1">&#39;FQPM1550&#39;</span><span class="p">]:</span> 
			<span class="n">nan_cut</span> <span class="o">=</span> <span class="mf">0.7</span>

		<span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_throughput</span><span class="o">&lt;</span><span class="n">nan_cut</span><span class="p">)</span>
		<span class="n">image</span><span class="p">[</span><span class="n">nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

	<span class="c1"># Mask companions </span>
	<span class="n">masked_image</span> <span class="o">=</span> <span class="n">mask_companions</span><span class="p">([</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">image</span><span class="p">)],</span> <span class="n">companion_xy</span><span class="p">,</span> <span class="n">mask_radius</span><span class="o">=</span><span class="n">mask_radius</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

	<span class="c1">##### Compute the 2D SNR</span>
	<span class="n">annulus_width</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="c1"># Build a lambda function to compute the standard deviation within an annulus</span>
	<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">masked_image</span><span class="p">[(</span><span class="n">rad_dist</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-</span><span class="n">annulus_width</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rad_dist</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">+</span><span class="n">annulus_width</span><span class="o">/</span><span class="mi">2</span><span class="p">)])</span>
	<span class="c1"># Define the radial separations </span>
	<span class="n">r</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
	<span class="c1"># Catch RuntimeWarnings from the np.nanstd() function at separations where all pixels == NaN</span>
	<span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
		<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
		<span class="c1"># Pass separations to our function, vectorize so it accepts numpy arrays</span>
		<span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="n">r</span><span class="p">)</span> 
	<span class="n">std_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span> <span class="c1"># Interpolate the results</span>
	<span class="c1"># Use radial array as a template array </span>
	<span class="n">std_2d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">rad_dist</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">std_2d</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
			<span class="n">std_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_interp</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="c1">#Assign each pixel it&#39;s standard deviation using the interpolation</span>

	<span class="c1"># Divide through to obtain the 2D SNR map.</span>
	<span class="n">image_snr</span> <span class="o">=</span> <span class="n">image</span> <span class="o">/</span> <span class="n">std_2d</span>
	
	<span class="c1">##### Now for each companion, try to fit a 2D gaussian to its location to estimate the peak SNR</span>
	<span class="n">companion_snrs</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">companion_xy</span><span class="p">:</span>
		<span class="n">bestfit</span> <span class="o">=</span> <span class="n">fakes</span><span class="o">.</span><span class="n">gaussfit2d</span><span class="p">(</span><span class="n">image_snr</span><span class="p">,</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">searchrad</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">guessfwhm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">refinefit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">companion_snrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bestfit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

	<span class="k">return</span> <span class="n">companion_snrs</span></div>

<div class="viewcode-block" id="contrast_curve"><a class="viewcode-back" href="../../autoapi/pancake/analysis/index.html#pancake.analysis.contrast_curve">[docs]</a><span class="k">def</span> <span class="nf">contrast_curve</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">references</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subtraction</span><span class="o">=</span><span class="s1">&#39;ADI&#39;</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">target_rolls</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">target_primary_source</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">reference_primary_sources</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">reference_rolls</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">klip_annuli</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">klip_subsections</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">klip_numbasis</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">klip_movement</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">get_companion_snrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clean_saved_files</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">outputdir</span><span class="o">=</span><span class="s1">&#39;./RESULTS/&#39;</span><span class="p">,</span> <span class="n">save_prefix</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_contrast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_klip_throughput</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_contrasts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

	<span class="c1">###### Perform some input checks on the user provided parameters</span>
	<span class="c1"># Check requested subtraction is valid</span>
	<span class="n">sub_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ADI&#39;</span><span class="p">,</span> <span class="s1">&#39;RDI&#39;</span><span class="p">,</span> <span class="s1">&#39;RDI+ADI&#39;</span><span class="p">,</span> <span class="s1">&#39;ADI+RDI&#39;</span><span class="p">]</span>
	<span class="k">if</span> <span class="n">subtraction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sub_methods</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specified subtraction method &#39;</span><span class="si">{}</span><span class="s2">&#39; not valid, possible methods are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subtraction</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sub_methods</span><span class="p">)))</span>
	<span class="k">if</span> <span class="n">subtraction</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RDI&#39;</span><span class="p">,</span> <span class="s1">&#39;RDI+ADI&#39;</span><span class="p">,</span> <span class="s1">&#39;ADI+RDI&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">references</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must identify reference scene observations through the &#39;references&#39; argument.&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">subtraction</span> <span class="o">==</span> <span class="s1">&#39;ADI&#39;</span> <span class="ow">and</span> <span class="n">references</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Specified reference scenes will not be used for ADI subtraction!&#39;</span><span class="p">)</span>
		<span class="n">references</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="c1"># Check the output directory exists, if not then create it</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">outputdir</span><span class="p">):</span>
		<span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">outputdir</span><span class="p">)</span>

	<span class="c1">#Convert certain arguments to lists if necessary</span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">references</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span> <span class="n">references</span> <span class="o">=</span> <span class="p">[</span><span class="n">references</span><span class="p">]</span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_rolls</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span> <span class="n">target_rolls</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_rolls</span><span class="p">]</span> 
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">klip_numbasis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span> <span class="n">klip_numbasis</span> <span class="o">=</span> <span class="p">[</span><span class="n">klip_numbasis</span><span class="p">]</span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filters</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span> <span class="n">filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">filters</span><span class="p">]</span> 
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span> <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">masks</span><span class="p">]</span> 

	<span class="c1"># Make sure strings are upper case</span>
	<span class="k">if</span> <span class="n">filters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="n">filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">filt</span> <span class="ow">in</span> <span class="n">filters</span><span class="p">]</span>
	<span class="k">if</span> <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">]</span>

	<span class="c1">#Get all of the observation / scenenames</span>
	<span class="n">obs_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">pancake_results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;EXTNAME&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">))]</span>

	<span class="c1">#Assign filters if no specifics are requested. </span>
	<span class="k">if</span> <span class="n">filters</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]:</span>
		<span class="n">filters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">obs_names</span> <span class="k">if</span> <span class="s1">&#39;:&#39;</span><span class="o">+</span><span class="n">target</span><span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">]))</span>

	<span class="c1">##### Identify the Sources that correspond to the central &quot;star&quot; for all of the used scenes. </span>
	<span class="n">primary_sources</span> <span class="o">=</span> <span class="n">identify_primary_sources</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">references</span><span class="o">=</span><span class="n">references</span><span class="p">,</span> <span class="n">target_primary_source</span><span class="o">=</span><span class="n">target_primary_source</span><span class="p">,</span> <span class="n">reference_primary_sources</span><span class="o">=</span><span class="n">reference_primary_sources</span><span class="p">)</span>

	<span class="c1">##### Start loop for creating contrast curves</span>
	<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>	<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing Contrast Curves (</span><span class="si">{}</span><span class="s1">)...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subtraction</span><span class="p">))</span>
	<span class="n">contrast_curve_dict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#This is where all the contrast curves will be saved</span>
	<span class="k">for</span> <span class="n">filt</span> <span class="ow">in</span> <span class="n">filters</span><span class="p">:</span>
		<span class="c1">### Get all of the target observations based on filter </span>
		<span class="n">raw_target_obs</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">obs_names</span> <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">filt</span> <span class="ow">in</span> <span class="n">j</span><span class="p">]</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">raw_target_obs</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find specified target/filter observation &#39;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&#39; within simulated results. Possible observations include: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">obs_names</span><span class="p">)))</span>
			
		<span class="n">all_simulated_masks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="n">j</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">raw_target_obs</span><span class="p">]))</span> <span class="c1">#This is all of the masks simulated for this filter</span>

		<span class="c1">###If all masks were requested, just use the all that are available. If not, use those specifically requested </span>
		<span class="k">if</span> <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span> 
			<span class="n">used_masks</span> <span class="o">=</span> <span class="n">all_simulated_masks</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">used_masks</span> <span class="o">=</span> <span class="n">masks</span>

		<span class="c1">### Now loop over all of the masks</span>
		<span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">used_masks</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> // </span><span class="si">{}</span><span class="s1">+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span>

			<span class="c1">### Get the target observations just for this mask</span>
			<span class="n">target_obs</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">raw_target_obs</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">j</span><span class="p">]</span>

			<span class="k">if</span> <span class="ow">not</span> <span class="n">target_obs</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find specified target/mask/filter observation &#39;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&#39; within simulated results. Possible observations include: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">obs_names</span><span class="p">)))</span>
			
			<span class="c1">### If necessary, get the reference observations</span>
			<span class="k">if</span> <span class="n">references</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">reference_obs</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">obs_names</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ref</span> <span class="ow">in</span> <span class="n">j</span> <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">references</span><span class="p">)</span> <span class="ow">and</span> <span class="n">filt</span> <span class="ow">in</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">j</span><span class="p">]</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">reference_obs</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find any reference/mask/filter observations of &#39;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&#39; within simulated results. Possible observations include: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;/</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&#39;, &#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">filt</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">references</span><span class="p">),</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">obs_names</span><span class="p">)))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">reference_obs</span> <span class="o">=</span> <span class="kc">None</span>

			<span class="c1">##### Create the KLIP datasets</span>
			<span class="n">processed</span> <span class="o">=</span> <span class="n">process_simulations</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">target_obs</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">primary_sources</span><span class="p">,</span> <span class="n">references</span><span class="o">=</span><span class="n">references</span><span class="p">,</span> <span class="n">reference_obs</span><span class="o">=</span><span class="n">reference_obs</span><span class="p">,</span> <span class="n">target_rolls</span><span class="o">=</span><span class="n">target_rolls</span><span class="p">,</span> <span class="n">reference_rolls</span><span class="o">=</span><span class="n">reference_rolls</span><span class="p">,</span> <span class="n">subtraction</span><span class="o">=</span><span class="n">subtraction</span><span class="p">)</span>

			<span class="c1">##### Perform the subtraction</span>
			<span class="c1">### Prior to the subtraction, must duplicate the datasets for KLIP throughput calculations</span>
			<span class="n">target_dataset_throughput</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">processed</span><span class="p">[</span><span class="s1">&#39;target_dataset&#39;</span><span class="p">])</span>
			<span class="k">if</span> <span class="n">processed</span><span class="p">[</span><span class="s1">&#39;psflib&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">psflib_throughput</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">processed</span><span class="p">[</span><span class="s1">&#39;psflib&#39;</span><span class="p">])</span>
				<span class="c1"># Preparing of the PSF library can raise a future warning, ignore it to keep terminal clean. </span>
				<span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
					<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
					<span class="n">psflib_throughput</span><span class="o">.</span><span class="n">prepare_library</span><span class="p">(</span><span class="n">target_dataset_throughput</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">psflib_throughput</span> <span class="o">=</span> <span class="kc">None</span>

			<span class="c1">### Define the prefix to save files</span>
			<span class="k">if</span> <span class="n">save_prefix</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
				<span class="n">klip_nb_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">klip_numbasis</span><span class="p">])</span>
				<span class="n">true_save_prefix</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">-nb</span><span class="si">{}</span><span class="s2">a</span><span class="si">{}</span><span class="s2">s</span><span class="si">{}</span><span class="s2">m</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">subtraction</span><span class="p">,</span> <span class="n">klip_nb_str</span><span class="p">,</span> <span class="n">klip_annuli</span><span class="p">,</span> <span class="n">klip_subsections</span><span class="p">,</span> <span class="n">klip_movement</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">true_save_prefix</span> <span class="o">=</span> <span class="n">save_prefix</span> 

			<span class="c1">### Subtraction routine</span>
			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>	<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--&gt; Performing KLIP Subtraction&#39;</span><span class="p">)</span>
			<span class="n">parallelized</span><span class="o">.</span><span class="n">klip_dataset</span><span class="p">(</span><span class="n">processed</span><span class="p">[</span><span class="s1">&#39;target_dataset&#39;</span><span class="p">],</span> <span class="n">outputdir</span><span class="o">=</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">fileprefix</span><span class="o">=</span><span class="n">true_save_prefix</span><span class="p">,</span> <span class="n">annuli</span><span class="o">=</span><span class="n">klip_annuli</span><span class="p">,</span> <span class="n">subsections</span><span class="o">=</span><span class="n">klip_subsections</span><span class="p">,</span> <span class="n">numbasis</span><span class="o">=</span><span class="n">klip_numbasis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">subtraction</span><span class="p">,</span> <span class="n">psf_library</span><span class="o">=</span><span class="n">processed</span><span class="p">[</span><span class="s1">&#39;psflib&#39;</span><span class="p">],</span> <span class="n">movement</span><span class="o">=</span><span class="n">klip_movement</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="c1">#This function doesn&#39;t return anything. Instead, all information is saved to a FITS file.  </span>
			<span class="n">subtracted_hdu_file</span> <span class="o">=</span> <span class="n">outputdir</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-KLmodes-all.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">true_save_prefix</span><span class="p">)</span>

			<span class="c1"># Get some information on the sources in our scene. </span>
			<span class="n">source_props</span> <span class="o">=</span> <span class="n">get_source_properties</span><span class="p">(</span><span class="n">pancake_results</span><span class="p">[</span><span class="n">target_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">primary_sources</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

			<span class="c1">##### Now want to turn the image results into a contrast curve for this mask and filter combination</span>
			<span class="c1"># Quickly grab the pixel scale for this filter </span>
			<span class="n">pixel_scale</span> <span class="o">=</span> <span class="n">pancake_results</span><span class="p">[</span><span class="n">target_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;PIXSCALE&#39;</span><span class="p">]</span> 
			<span class="c1"># Also need the vegamag of the primary source in the target image for this specific filter</span>
			<span class="n">nsources</span> <span class="o">=</span> <span class="n">pancake_results</span><span class="p">[</span><span class="n">target_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;NSOURCES&#39;</span><span class="p">]</span>

			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>	<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--&gt; Extracting Contrast Curve&#39;</span><span class="p">)</span>
			<span class="n">all_contrasts</span> <span class="o">=</span> <span class="n">compute_contrast</span><span class="p">(</span><span class="n">subtracted_hdu_file</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">processed</span><span class="p">[</span><span class="s1">&#39;offaxis_psf_stamp&#39;</span><span class="p">],</span> <span class="n">processed</span><span class="p">[</span><span class="s1">&#39;offaxis_peak_flux&#39;</span><span class="p">],</span> <span class="n">target_dataset_throughput</span><span class="p">,</span> <span class="n">psflib_throughput</span><span class="p">,</span> <span class="n">primary_vegamag</span><span class="o">=</span><span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;target_primary_vegamag&#39;</span><span class="p">],</span> <span class="n">pixel_scale</span><span class="o">=</span><span class="n">pixel_scale</span><span class="p">,</span> <span class="n">annuli</span><span class="o">=</span><span class="n">klip_annuli</span><span class="p">,</span> <span class="n">subsections</span><span class="o">=</span><span class="n">klip_subsections</span><span class="p">,</span> <span class="n">numbasis</span><span class="o">=</span><span class="n">klip_numbasis</span><span class="p">,</span> <span class="n">subtraction</span><span class="o">=</span><span class="n">subtraction</span><span class="p">,</span> <span class="n">movement</span><span class="o">=</span><span class="n">klip_movement</span><span class="p">,</span> <span class="n">companion_xy</span><span class="o">=</span><span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_xy&#39;</span><span class="p">],</span> <span class="n">outputdir</span><span class="o">=</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">plot_klip_throughput</span><span class="o">=</span><span class="n">plot_klip_throughput</span><span class="p">)</span>

			<span class="n">contrast_curve_dict</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">())]</span> <span class="o">=</span> <span class="n">all_contrasts</span>

			<span class="c1">##### Now that we&#39;ve done all this, it&#39;s also possible to grab the SNR for any companions in the image</span>
			<span class="k">if</span> <span class="n">get_companion_snrs</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_xy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>	<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Unable to compute companion SNR as no companions were identified in target image.&#39;</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>	<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--&gt; Estimating Companion SNR&#39;</span><span class="p">)</span>
					<span class="n">snrs</span> <span class="o">=</span> <span class="n">companion_snrs</span><span class="p">(</span><span class="n">subtracted_hdu_file</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_xy&#39;</span><span class="p">])</span>
					<span class="n">contrast_curve_dict</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">())][</span><span class="s1">&#39;companion_snrs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snrs</span>
					<span class="n">contrast_curve_dict</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">())][</span><span class="s1">&#39;companion_contrast&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_contrasts&#39;</span><span class="p">]</span>
					<span class="n">contrast_curve_dict</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">())][</span><span class="s1">&#39;companion_seps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_seps&#39;</span><span class="p">]</span>
					<span class="n">contrast_curve_dict</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">())][</span><span class="s1">&#39;companion_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_names&#39;</span><span class="p">]</span>

			<span class="c1"># Save output contrasts to a file so things don&#39;t need to be calculated again.</span>
			<span class="k">if</span> <span class="n">save_contrasts</span><span class="p">:</span>
				<span class="c1"># Create file name</span>
				<span class="n">ccurve_save_file</span> <span class="o">=</span> <span class="n">subtracted_hdu_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.fits&#39;</span><span class="p">,</span> <span class="s1">&#39;_CURVES.json&#39;</span><span class="p">)</span>
				<span class="c1"># Create a function to convert numpy arrays to lists within the dictionary</span>
				<span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
					<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
						<span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
					<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Value in contrast curve dictionary not serializable by JSON.&#39;</span><span class="p">)</span>

				<span class="c1"># Save file</span>
				<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">ccurve_save_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
					<span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">contrast_curve_dict</span><span class="p">[</span><span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39;+&#39;</span><span class="o">+</span><span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">()],</span> <span class="n">f</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>

			<span class="c1"># Default behaviour is to leave KLIP subtracted files, but if requested the files **for this run only** will be deleted.  </span>
			<span class="k">if</span> <span class="n">clean_saved_files</span><span class="p">:</span>
				<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">subtracted_hdu_file</span><span class="p">)</span>

			<span class="c1"># Plot contrast curve for this filter/mask combo if requested. </span>
			<span class="k">if</span> <span class="n">plot_contrast</span><span class="p">:</span>
				<span class="c1">##### First make a plot for the straightforward contrast </span>
				<span class="n">plot_save_file</span> <span class="o">=</span> <span class="n">subtracted_hdu_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.fits&#39;</span><span class="p">,</span> <span class="s1">&#39;_CURVES.png&#39;</span><span class="p">)</span>
				<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
				<span class="n">separation</span> <span class="o">=</span> <span class="n">contrast_curve_dict</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">())][</span><span class="s1">&#39;separation_arcsec&#39;</span><span class="p">]</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">separation</span><span class="p">,</span> <span class="n">all_contrasts</span><span class="p">[</span><span class="s1">&#39;contrast&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#577B51&quot;</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;5$</span><span class="se">\\</span><span class="s1">sigma$ Contrast&#39;</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">all_contrasts</span><span class="p">[</span><span class="s1">&#39;separation_arcsec_raw5sig&#39;</span><span class="p">],</span> <span class="n">all_contrasts</span><span class="p">[</span><span class="s1">&#39;contrast_raw5sig&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#A1BF9C&quot;</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;5$</span><span class="se">\\</span><span class="s1">sigma$ Standard Deviation&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
				<span class="c1"># Also add companion magnitudes if necessary. </span>
				<span class="k">if</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_seps&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_contrasts&#39;</span><span class="p">]:</span>
					<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_seps&#39;</span><span class="p">],</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_contrasts&#39;</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_names&#39;</span><span class="p">]):</span>
						<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_seps&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_contrasts&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Contrast&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Separation (&quot;)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> // </span><span class="si">{}</span><span class="s1">+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">()),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
				<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">plot_save_file</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>

				<span class="c1">##### Now make a plot for the absolute magnitude contrast limit reached. </span>
				<span class="n">plot_save_file</span> <span class="o">=</span> <span class="n">subtracted_hdu_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.fits&#39;</span><span class="p">,</span> <span class="s1">&#39;_MAGCURVES.png&#39;</span><span class="p">)</span>
				<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span> 
				<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
				<span class="n">separation</span> <span class="o">=</span> <span class="n">contrast_curve_dict</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">())][</span><span class="s1">&#39;separation_arcsec&#39;</span><span class="p">]</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">separation</span><span class="p">,</span> <span class="n">all_contrasts</span><span class="p">[</span><span class="s1">&#39;absmag&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#577B51&quot;</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;5$</span><span class="se">\\</span><span class="s1">sigma$ Sensitivity Limit&#39;</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">all_contrasts</span><span class="p">[</span><span class="s1">&#39;separation_arcsec_raw5sig&#39;</span><span class="p">],</span> <span class="n">all_contrasts</span><span class="p">[</span><span class="s1">&#39;absmag_raw5sig&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#A1BF9C&quot;</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;5$</span><span class="se">\\</span><span class="s1">sigma$ Standard Deviation&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
				<span class="c1"># Also add companion magnitudes if necessary. </span>
				<span class="k">if</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_seps&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_vegamags&#39;</span><span class="p">]:</span>
					<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_seps&#39;</span><span class="p">],</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_vegamags&#39;</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_names&#39;</span><span class="p">]):</span>
						<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_seps&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">source_props</span><span class="p">[</span><span class="s1">&#39;comp_vegamags&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Apparent Magnitude&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Separation (&quot;)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> // </span><span class="si">{}</span><span class="s1">+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">filt</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">mask</span><span class="o">.</span><span class="n">upper</span><span class="p">()),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
				<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">plot_save_file</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">contrast_curve_dict</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Aarynn Carter.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>